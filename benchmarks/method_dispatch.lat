// Benchmark: Struct Method Dispatch
// Measures struct creation, field access, and method-style callable field invocation.
// Tests struct allocation and field lookup performance.

struct Point {
    x: Int,
    y: Int,
}

struct Counter {
    value: Int,
    increment: Fn,
    get_value: Fn,
}

fn make_counter(start: Int) -> Counter {
    return Counter {
        value: start,
        increment: |self, n| {
            self.value + n
        },
        get_value: |self| {
            self.value
        },
    }
}

fn main() {
    let t0 = time()

    // Struct creation and field access (100K iterations)
    flux field_sum = 0
    flux i = 0
    while i < 100000 {
        let p = Point { x: i, y: i * 2 }
        field_sum = field_sum + p.x + p.y
        i = i + 1
    }
    print("field sum: ${field_sum}")

    // Callable struct fields (50K iterations)
    flux counter_sum = 0
    flux j = 0
    while j < 50000 {
        let c = make_counter(j)
        let val = c.increment(10)
        counter_sum = counter_sum + val
        j = j + 1
    }
    print("counter sum: ${counter_sum}")

    // Nested struct field access
    flux nested_sum = 0
    flux k = 0
    while k < 50000 {
        let p1 = Point { x: k, y: k + 1 }
        let p2 = Point { x: p1.x * 2, y: p1.y * 2 }
        nested_sum = nested_sum + p2.x + p2.y
        k = k + 1
    }
    print("nested sum: ${nested_sum}")

    let elapsed = time() - t0
    print("elapsed: ${elapsed}ms")
}
