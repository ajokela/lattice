// ============================================================================
// Lattice Self-Hosted Compiler — latc.lat
// Reads .lat source, emits bytecode, writes .latc files.
// Usage: clat compiler/latc.lat input.lat output.latc
// ============================================================================

// ============================================================================
// Section 1: Opcode constants
// ============================================================================

let OP_CONSTANT       = 0
let OP_NIL            = 1
let OP_TRUE           = 2
let OP_FALSE          = 3
let OP_UNIT           = 4
let OP_POP            = 5
let OP_DUP            = 6
let OP_SWAP           = 7

let OP_ADD            = 8
let OP_SUB            = 9
let OP_MUL            = 10
let OP_DIV            = 11
let OP_MOD            = 12
let OP_NEG            = 13
let OP_NOT            = 14

let OP_BIT_AND        = 15
let OP_BIT_OR         = 16
let OP_BIT_XOR        = 17
let OP_BIT_NOT        = 18
let OP_LSHIFT         = 19
let OP_RSHIFT         = 20

let OP_EQ             = 21
let OP_NEQ            = 22
let OP_LT             = 23
let OP_GT             = 24
let OP_LTEQ           = 25
let OP_GTEQ           = 26

let OP_CONCAT         = 27

let OP_GET_LOCAL      = 28
let OP_SET_LOCAL      = 29
let OP_GET_GLOBAL     = 30
let OP_SET_GLOBAL     = 31
let OP_DEFINE_GLOBAL  = 32
let OP_GET_UPVALUE    = 33
let OP_SET_UPVALUE    = 34
let OP_CLOSE_UPVALUE  = 35

let OP_JUMP           = 36
let OP_JUMP_IF_FALSE  = 37
let OP_JUMP_IF_TRUE   = 38
let OP_JUMP_IF_NOT_NIL = 39
let OP_LOOP           = 40

let OP_CALL           = 41
let OP_CLOSURE        = 42
let OP_RETURN         = 43

let OP_ITER_INIT      = 44
let OP_ITER_NEXT      = 45

let OP_BUILD_ARRAY    = 46
let OP_ARRAY_FLATTEN  = 47
let OP_BUILD_MAP      = 48
let OP_BUILD_TUPLE    = 49
let OP_BUILD_STRUCT   = 50
let OP_BUILD_RANGE    = 51
let OP_BUILD_ENUM     = 52
let OP_INDEX          = 53
let OP_SET_INDEX      = 54
let OP_GET_FIELD      = 55
let OP_SET_FIELD      = 56
let OP_INVOKE         = 57
let OP_INVOKE_LOCAL   = 58
let OP_INVOKE_GLOBAL  = 59
let OP_SET_INDEX_LOCAL = 60

let OP_PUSH_EXCEPTION_HANDLER = 61
let OP_POP_EXCEPTION_HANDLER  = 62
let OP_THROW          = 63
let OP_TRY_UNWRAP     = 64

let OP_DEFER_PUSH     = 65
let OP_DEFER_RUN      = 66

let OP_FREEZE         = 67
let OP_THAW           = 68
let OP_CLONE          = 69
let OP_MARK_FLUID     = 70

let OP_REACT          = 71
let OP_UNREACT        = 72
let OP_BOND           = 73
let OP_UNBOND         = 74
let OP_SEED           = 75
let OP_UNSEED         = 76
let OP_FREEZE_VAR     = 77
let OP_THAW_VAR       = 78
let OP_SUBLIMATE_VAR  = 79
let OP_SUBLIMATE      = 80

let OP_PRINT          = 81

let OP_IMPORT         = 82

let OP_SCOPE          = 83
let OP_SELECT         = 84

let OP_INC_LOCAL      = 85
let OP_DEC_LOCAL      = 86
let OP_ADD_INT        = 87
let OP_SUB_INT        = 88
let OP_MUL_INT        = 89
let OP_LT_INT         = 90
let OP_LTEQ_INT       = 91
let OP_LOAD_INT8      = 92

let OP_CONSTANT_16    = 93
let OP_GET_GLOBAL_16  = 94
let OP_SET_GLOBAL_16  = 95
let OP_DEFINE_GLOBAL_16 = 96
let OP_CLOSURE_16     = 97
let OP_INVOKE_LOCAL_16  = 98
let OP_INVOKE_GLOBAL_16 = 99

let OP_RESET_EPHEMERAL = 100
let OP_SET_LOCAL_POP  = 101
let OP_CHECK_TYPE     = 102
let OP_CHECK_RETURN_TYPE = 103
let OP_IS_CRYSTAL     = 104
let OP_IS_FLUID       = 105
let OP_FREEZE_EXCEPT  = 106
let OP_FREEZE_FIELD   = 107
let OP_HALT           = 108

// .latc constant tags
let TAG_INT     = 0
let TAG_FLOAT   = 1
let TAG_BOOL    = 2
let TAG_STR     = 3
let TAG_NIL     = 4
let TAG_UNIT    = 5
let TAG_CLOSURE = 6

// ============================================================================
// Section 2: Token stream / cursor helpers
// ============================================================================

flux tokens = []
flux pos = 0

fn peek() {
    if pos >= len(tokens) {
        return nil
    }
    return tokens[pos]
}

fn peek_type() {
    if pos >= len(tokens) {
        return "EOF"
    }
    return tokens[pos].type
}

fn peek_text() {
    if pos >= len(tokens) {
        return ""
    }
    return tokens[pos].text
}

fn advance() {
    let t = tokens[pos]
    pos = pos + 1
    return t
}

fn expect(typ: any, text: any) {
    let t = peek()
    if t == nil {
        compiler_error("expected '" + to_string(text) + "' but got EOF", 0)
    }
    if typ != nil {
        if t.type != typ {
            compiler_error("expected token type '" + typ + "' but got '" + t.type + "' ('" + t.text + "')", t.line)
        }
    }
    if text != nil {
        if t.text != text {
            compiler_error("expected '" + text + "' but got '" + t.text + "'", t.line)
        }
    }
    return advance()
}

fn match_tok(typ: any, text: any) {
    let t = peek()
    if t == nil { return false }
    if typ != nil {
        if t.type != typ { return false }
    }
    if text != nil {
        if t.text != text { return false }
    }
    advance()
    return true
}

fn current_line() {
    if pos < len(tokens) {
        return tokens[pos].line
    }
    if pos > 0 {
        return tokens[pos - 1].line
    }
    return 1
}

// ============================================================================
// Section 3: Compiler state
// ============================================================================

// Chunk is represented as 4 separate arrays (since Lattice structs are
// pass-by-value, nested array mutation doesn't propagate).
// We use a "saved chunks" array for completed function chunks.

flux code = []
flux c_lines = []
flux constants = []       // array of [tag, ...values]
flux local_names = []

// Local variable tracking
// Each local stored as 3 parallel arrays for mutability
flux local_name_arr = []
flux local_depth_arr = []
flux local_captured_arr = []
flux local_count = 0
flux scope_depth = 0

// Upvalue tracking
flux upvalue_index_arr = []
flux upvalue_islocal_arr = []
flux upvalue_count = 0
flux func_type = "script"

// Break/continue tracking
flux break_jumps = []
flux break_count = 0
flux loop_start_pos = 0
flux loop_depth = 0
flux loop_break_local_count = 0
flux loop_continue_local_count = 0

// Auto-call main() tracking
flux has_main_fn = false

// Known enum names for BUILD_ENUM codegen
flux known_enums = []

// String constant deduplication (per-chunk intern map)
flux string_intern_map = Map::new()

// Contract tracking (require/ensure)
// ensure_slots stores local variable slots where ensure closures are saved
flux ensure_slots = []
flux ensure_messages = []
flux ensure_count = 0
flux current_func_name = ""

// Compiler stack for save/restore during function compilation
// Each entry is an array: [code, c_lines, constants, local_names,
//   local_name_arr, local_depth_arr, local_captured_arr, local_count,
//   scope_depth, upvalue_index_arr, upvalue_islocal_arr, upvalue_count,
//   func_type, break_jumps, break_count, loop_start_pos, loop_depth,
//   loop_break_local_count, loop_continue_local_count, string_intern_map,
//   ensure_slots, ensure_messages, ensure_count, current_func_name]
flux compiler_stack = []

fn save_compiler() {
    // Snapshot current state into an array
    flux state = [
        code, c_lines, constants, local_names,
        local_name_arr, local_depth_arr, local_captured_arr, local_count,
        scope_depth, upvalue_index_arr, upvalue_islocal_arr, upvalue_count,
        func_type, break_jumps, break_count, loop_start_pos, loop_depth,
        loop_break_local_count, loop_continue_local_count, string_intern_map,
        ensure_slots, ensure_messages, ensure_count, current_func_name
    ]
    compiler_stack.push(state)
}

fn restore_compiler() {
    let state = compiler_stack.pop()
    code = state[0]
    c_lines = state[1]
    constants = state[2]
    local_names = state[3]
    local_name_arr = state[4]
    local_depth_arr = state[5]
    local_captured_arr = state[6]
    local_count = state[7]
    scope_depth = state[8]
    upvalue_index_arr = state[9]
    upvalue_islocal_arr = state[10]
    upvalue_count = state[11]
    func_type = state[12]
    break_jumps = state[13]
    break_count = state[14]
    loop_start_pos = state[15]
    loop_depth = state[16]
    loop_break_local_count = state[17]
    loop_continue_local_count = state[18]
    string_intern_map = state[19]
    ensure_slots = state[20]
    ensure_messages = state[21]
    ensure_count = state[22]
    current_func_name = state[23]
}

// Snapshot the current chunk into an array for serialization
// Returns [code, c_lines, constants, local_names]
fn snapshot_chunk() {
    return [code, c_lines, constants, local_names]
}

// ============================================================================
// Section 4: Error reporting
// ============================================================================

fn compiler_error(msg: any, line: any) {
    if line > 0 {
        eprint("compile error [line " + to_string(line) + "]: " + msg)
    } else {
        eprint("compile error: " + msg)
    }
    exit(1)
}

// ============================================================================
// Section 5: Emit helpers
// ============================================================================

fn emit_byte(byte: any, line: any) {
    code.push(byte & 255)
    c_lines.push(line)
}

fn emit_bytes(b1: any, b2: any, line: any) {
    emit_byte(b1, line)
    emit_byte(b2, line)
}

fn emit_wide_op(op: any, op16: any, idx: any, line: any) {
    if idx > 255 {
        emit_byte(op16, line)
        emit_byte((idx >> 8) & 255, line)
        emit_byte(idx & 255, line)
    } else {
        emit_bytes(op, idx, line)
    }
}

fn add_constant(val: any) {
    let idx = len(constants)
    if idx > 65535 {
        compiler_error("too many constants in one chunk", current_line())
    }
    constants.push(val)
    return idx
}

fn emit_constant(val: any, line: any) {
    let idx = add_constant(val)
    emit_wide_op(OP_CONSTANT, OP_CONSTANT_16, idx, line)
    return idx
}

fn emit_jump(op: any, line: any) {
    emit_byte(op, line)
    emit_byte(255, line)
    emit_byte(255, line)
    return len(code) - 2
}

fn patch_jump(offset: any) {
    let jump = len(code) - offset - 2
    if jump > 65535 {
        compiler_error("jump offset too large", current_line())
    }
    code[offset] = (jump >> 8) & 255
    code[offset + 1] = jump & 255
}

fn emit_loop(loop_start: any, line: any) {
    emit_byte(OP_LOOP, line)
    let offset = len(code) - loop_start + 2
    if offset > 65535 {
        compiler_error("loop body too large", current_line())
    }
    emit_byte((offset >> 8) & 255, line)
    emit_byte(offset & 255, line)
}

// ============================================================================
// Section 6: Constant pool management
// ============================================================================

// Constants are stored as arrays: [TAG, ...data]
// TAG_INT: [0, int_value]
// TAG_FLOAT: [1, float_value]
// TAG_BOOL: [2, bool_value]
// TAG_STR: [3, string_value]
// TAG_NIL: [4]
// TAG_UNIT: [5]
// TAG_CLOSURE: [6, param_count, has_variadic, chunk_snapshot]
//   where chunk_snapshot = [code, lines, constants, local_names]

fn make_int_const(val: any) {
    return [TAG_INT, val]
}

fn make_float_const(val: any) {
    return [TAG_FLOAT, val]
}

fn make_string_const(val: any) {
    return [TAG_STR, val]
}

fn make_bool_const(val: any) {
    return [TAG_BOOL, val]
}

fn make_nil_const() {
    return [TAG_NIL]
}

fn make_unit_const() {
    return [TAG_UNIT]
}

fn make_closure_const(param_count: any, has_variadic: any, chunk_snap: any) {
    return [TAG_CLOSURE, param_count, has_variadic, chunk_snap]
}

fn string_constant(name: any) {
    let cached = string_intern_map[name]
    if cached != nil { return cached }
    let idx = add_constant(make_string_const(name))
    string_intern_map[name] = idx
    return idx
}

// ============================================================================
// Section 7: Scope & variable resolution
// ============================================================================

fn begin_scope() {
    scope_depth = scope_depth + 1
}

fn end_scope(line: any) {
    // Run defers at current scope level (before decrementing)
    emit_byte(OP_UNIT, line)
    emit_byte(OP_DEFER_RUN, line)
    emit_byte(scope_depth, line)
    emit_byte(OP_POP, line)

    scope_depth = scope_depth - 1
    while local_count > 0 {
        if local_depth_arr[local_count - 1] <= scope_depth {
            break
        }
        if local_captured_arr[local_count - 1] {
            emit_byte(OP_CLOSE_UPVALUE, line)
        } else {
            emit_byte(OP_POP, line)
        }
        local_count = local_count - 1
    }
}

fn end_scope_preserve_tos(line: any) {
    // Like end_scope but preserves TOS (expression result) across local pops.
    // Emits OP_SWAP before each POP/CLOSE_UPVALUE to sink result past each local.
    emit_byte(OP_DEFER_RUN, line)
    emit_byte(scope_depth, line)
    scope_depth = scope_depth - 1
    while local_count > 0 {
        if local_depth_arr[local_count - 1] <= scope_depth {
            break
        }
        emit_byte(OP_SWAP, line)
        if local_captured_arr[local_count - 1] {
            emit_byte(OP_CLOSE_UPVALUE, line)
        } else {
            emit_byte(OP_POP, line)
        }
        local_count = local_count - 1
    }
}

fn add_local(name: any) {
    let slot = local_count
    if local_count >= len(local_name_arr) {
        local_name_arr.push(name)
        local_depth_arr.push(scope_depth)
        local_captured_arr.push(false)
    } else {
        local_name_arr[local_count] = name
        local_depth_arr[local_count] = scope_depth
        local_captured_arr[local_count] = false
    }
    local_count = local_count + 1
    while len(local_names) <= slot {
        local_names.push(nil)
    }
    local_names[slot] = name
}

fn resolve_local(name: any) {
    flux i = local_count - 1
    while i >= 0 {
        if local_name_arr[i] == name {
            return i
        }
        i = i - 1
    }
    return -1
}

fn add_upvalue(index: any, is_local: any) {
    flux i = 0
    while i < upvalue_count {
        if upvalue_index_arr[i] == index {
            if upvalue_islocal_arr[i] == is_local {
                return i
            }
        }
        i = i + 1
    }
    if upvalue_count >= 256 {
        compiler_error("too many upvalues in one function", current_line())
    }
    if upvalue_count >= len(upvalue_index_arr) {
        upvalue_index_arr.push(index)
        upvalue_islocal_arr.push(is_local)
    } else {
        upvalue_index_arr[upvalue_count] = index
        upvalue_islocal_arr[upvalue_count] = is_local
    }
    let result = upvalue_count
    upvalue_count = upvalue_count + 1
    return result
}

fn resolve_upvalue_in(stack_idx: any, name: any) {
    if stack_idx < 0 {
        return -1
    }
    let enclosing = compiler_stack[stack_idx]
    // enclosing[4] = local_name_arr, [7] = local_count, [6] = local_captured_arr
    let enc_names = enclosing[4]
    let enc_count = enclosing[7]
    let enc_captured = enclosing[6]

    flux i = enc_count - 1
    while i >= 0 {
        if enc_names[i] == name {
            // Mark captured — but we can't mutate the saved array directly
            // since arrays in the saved state are copies. We need to update
            // the compiler_stack entry.
            // Actually, arrays ARE mutated in place in Lattice for .push and []=
            enc_captured[i] = true
            return add_upvalue(i, true)
        }
        i = i - 1
    }

    if stack_idx > 0 {
        let outer = resolve_upvalue_in(stack_idx - 1, name)
        if outer >= 0 {
            return add_upvalue(outer, false)
        }
    }

    return -1
}

fn resolve_upvalue(name: any) {
    let stack_idx = len(compiler_stack) - 1
    return resolve_upvalue_in(stack_idx, name)
}

fn emit_variable_get(name: any, line: any) {
    let slot = resolve_local(name)
    if slot >= 0 {
        emit_bytes(OP_GET_LOCAL, slot, line)
        return
    }
    let up = resolve_upvalue(name)
    if up >= 0 {
        emit_bytes(OP_GET_UPVALUE, up, line)
        return
    }
    let idx = string_constant(name)
    emit_wide_op(OP_GET_GLOBAL, OP_GET_GLOBAL_16, idx, line)
}

fn emit_variable_set(name: any, line: any) {
    let slot = resolve_local(name)
    if slot >= 0 {
        emit_bytes(OP_SET_LOCAL, slot, line)
        return
    }
    let up = resolve_upvalue(name)
    if up >= 0 {
        emit_bytes(OP_SET_UPVALUE, up, line)
        return
    }
    let idx = string_constant(name)
    emit_wide_op(OP_SET_GLOBAL, OP_SET_GLOBAL_16, idx, line)
}

fn emit_variable_set_pop(name: any, line: any) {
    let slot = resolve_local(name)
    if slot >= 0 {
        emit_bytes(OP_SET_LOCAL_POP, slot, line)
        return
    }
    let up = resolve_upvalue(name)
    if up >= 0 {
        emit_bytes(OP_SET_UPVALUE, up, line)
        emit_byte(OP_POP, line)
        return
    }
    let idx = string_constant(name)
    emit_wide_op(OP_SET_GLOBAL, OP_SET_GLOBAL_16, idx, line)
    emit_byte(OP_POP, line)
}

// ============================================================================
// Section 7b: Ensure contract emission
// ============================================================================

// Emit ensure checks before a return. Expects return value on TOS.
// Leaves it on TOS unchanged.
fn emit_ensure_checks(line: any) {
    if ensure_count == 0 { return }
    flux i = 0
    while i < ensure_count {
        let slot = ensure_slots[i]
        let msg = ensure_messages[i]
        // Stack: [..., return_val]
        emit_byte(OP_DUP, line)              // [..., ret, ret_copy]
        emit_bytes(OP_GET_LOCAL, slot, line)  // [..., ret, ret_copy, closure]
        emit_byte(OP_SWAP, line)             // [..., ret, closure, ret_copy]
        emit_bytes(OP_CALL, 1, line)         // [..., ret, result]
        let ok_jump = emit_jump(OP_JUMP_IF_TRUE, line)
        emit_byte(OP_POP, line)              // pop false
        emit_byte(OP_POP, line)              // pop return value
        let full_msg = "ensure failed in '" + current_func_name + "': " + msg
        emit_constant(make_string_const(full_msg), line)
        emit_byte(OP_THROW, line)
        patch_jump(ok_jump)
        emit_byte(OP_POP, line)              // pop true
        i = i + 1
    }
}

// ============================================================================
// Section 8: Expression parsing — precedence climbing
// ============================================================================

fn parse_expression() {
    return parse_or()
}

fn parse_or() {
    let line = current_line()
    parse_nil_coalesce()
    while peek_type() == "||" {
        advance()
        let jump = emit_jump(OP_JUMP_IF_TRUE, line)
        emit_byte(OP_POP, line)
        parse_nil_coalesce()
        patch_jump(jump)
    }
}

fn parse_nil_coalesce() {
    let line = current_line()
    parse_and()
    while peek_type() == "??" {
        advance()
        let end_jump = emit_jump(OP_JUMP_IF_NOT_NIL, line)
        emit_byte(OP_POP, line)
        parse_and()
        patch_jump(end_jump)
    }
}

fn parse_and() {
    let line = current_line()
    parse_equality()
    while peek_type() == "&&" {
        advance()
        let jump = emit_jump(OP_JUMP_IF_FALSE, line)
        emit_byte(OP_POP, line)
        parse_equality()
        patch_jump(jump)
    }
}

fn parse_equality() {
    let line = current_line()
    parse_comparison()
    flux pt = peek_type()
    while pt == "==" || pt == "!=" {
        let op = advance().text
        parse_comparison()
        if op == "==" {
            emit_byte(OP_EQ, line)
        } else {
            emit_byte(OP_NEQ, line)
        }
        pt = peek_type()
    }
}

fn parse_comparison() {
    let line = current_line()
    parse_bitwise_or()
    flux pt = peek_type()
    while pt == "<" || pt == ">" || pt == "<=" || pt == ">=" {
        let op = advance().text
        parse_bitwise_or()
        match op {
            "<" => emit_byte(OP_LT, line),
            ">" => emit_byte(OP_GT, line),
            "<=" => emit_byte(OP_LTEQ, line),
            _ => emit_byte(OP_GTEQ, line)
        }
        pt = peek_type()
    }
}

fn parse_bitwise_or() {
    let line = current_line()
    parse_bitwise_xor()
    while peek_type() == "|" {
        advance()
        parse_bitwise_xor()
        emit_byte(OP_BIT_OR, line)
    }
}

fn parse_bitwise_xor() {
    let line = current_line()
    parse_bitwise_and()
    while peek_type() == "^" {
        advance()
        parse_bitwise_and()
        emit_byte(OP_BIT_XOR, line)
    }
}

fn parse_bitwise_and() {
    let line = current_line()
    parse_shift()
    while peek_type() == "&" {
        advance()
        parse_shift()
        emit_byte(OP_BIT_AND, line)
    }
}

fn parse_shift() {
    let line = current_line()
    parse_range()
    flux pt = peek_type()
    while pt == "<<" || pt == ">>" {
        let op = advance().text
        parse_range()
        if op == "<<" {
            emit_byte(OP_LSHIFT, line)
        } else {
            emit_byte(OP_RSHIFT, line)
        }
        pt = peek_type()
    }
}

fn parse_range() {
    let line = current_line()
    parse_concat()
    if peek_type() == ".." {
        advance()
        parse_concat()
        emit_byte(OP_BUILD_RANGE, line)
    }
}

fn parse_concat() {
    let line = current_line()
    parse_term()
    while peek_type() == "++" {
        advance()
        parse_term()
        emit_byte(OP_CONCAT, line)
    }
}

fn parse_term() {
    let line = current_line()
    parse_factor()
    flux pt = peek_type()
    while pt == "+" || pt == "-" {
        let op = advance().text
        parse_factor()
        if op == "+" {
            emit_byte(OP_ADD, line)
        } else {
            emit_byte(OP_SUB, line)
        }
        pt = peek_type()
    }
}

fn parse_factor() {
    let line = current_line()
    parse_unary()
    flux pt = peek_type()
    while pt == "*" || pt == "/" || pt == "%" {
        let op = advance().text
        parse_unary()
        match op {
            "*" => emit_byte(OP_MUL, line),
            "/" => emit_byte(OP_DIV, line),
            _ => emit_byte(OP_MOD, line)
        }
        pt = peek_type()
    }
}

fn parse_unary() {
    let line = current_line()
    if peek_type() == "-" {
        advance()
        parse_unary()
        emit_byte(OP_NEG, line)
        return
    }
    if peek_type() == "!" {
        advance()
        parse_unary()
        emit_byte(OP_NOT, line)
        return
    }
    if peek_type() == "~" {
        advance()
        parse_unary()
        emit_byte(OP_BIT_NOT, line)
        return
    }
    parse_postfix()
}

fn parse_postfix() {
    let line = current_line()
    parse_primary()

    loop {
        let pt = peek_type()
        if pt == "(" {
            advance()
            flux arg_count = 0
            if peek_type() != ")" {
                parse_expression()
                arg_count = arg_count + 1
                while peek_type() == "," {
                    advance()
                    parse_expression()
                    arg_count = arg_count + 1
                }
            }
            expect(nil, ")")
            emit_bytes(OP_CALL, arg_count, line)
        } else { if pt == "[" || pt == "?[" {
            let optional = pt == "?["
            advance()
            flux end_jump = 0
            if optional {
                // If TOS is nil, short-circuit to nil
                let skip = emit_jump(OP_JUMP_IF_NOT_NIL, line)
                end_jump = emit_jump(OP_JUMP, line)
                patch_jump(skip)
            }
            parse_expression()
            expect(nil, "]")
            emit_byte(OP_INDEX, line)
            if optional {
                patch_jump(end_jump)
            }
        } else { if pt == "." || pt == "?." {
            let optional = pt == "?."
            let receiver_code_pos = len(code)
            advance()
            let field_name = expect("identifier", nil).text
            if peek_type() == "(" {
                // Method call
                if !optional {
                    // Check if receiver was a simple local or global load
                    let is_local_recv = receiver_code_pos >= 2 && code[receiver_code_pos - 2] == OP_GET_LOCAL
                    let is_global_recv = receiver_code_pos >= 2 && code[receiver_code_pos - 2] == OP_GET_GLOBAL && !(receiver_code_pos >= 3 && code[receiver_code_pos - 3] == OP_GET_GLOBAL_16)
                    let receiver_slot = 0
                    if is_local_recv || is_global_recv {
                        receiver_slot = code[receiver_code_pos - 1]
                        // Remove the GET_LOCAL/GET_GLOBAL we already emitted
                        code.pop()
                        code.pop()
                        c_lines.pop()
                        c_lines.pop()
                    }

                    advance()
                    flux arg_count = 0
                    if peek_type() != ")" {
                        parse_expression()
                        arg_count = arg_count + 1
                        while peek_type() == "," {
                            advance()
                            parse_expression()
                            arg_count = arg_count + 1
                        }
                    }
                    expect(nil, ")")
                    let name_idx = string_constant(field_name)
                    if is_local_recv {
                        if name_idx > 255 {
                            emit_byte(OP_INVOKE_LOCAL_16, line)
                            emit_byte(receiver_slot, line)
                            emit_byte(name_idx / 256, line)
                            emit_byte(name_idx % 256, line)
                            emit_byte(arg_count, line)
                        } else {
                            emit_byte(OP_INVOKE_LOCAL, line)
                            emit_byte(receiver_slot, line)
                            emit_byte(name_idx, line)
                            emit_byte(arg_count, line)
                        }
                    } else { if is_global_recv {
                        if receiver_slot > 255 || name_idx > 255 {
                            emit_byte(OP_INVOKE_GLOBAL_16, line)
                            emit_byte(receiver_slot / 256, line)
                            emit_byte(receiver_slot % 256, line)
                            emit_byte(name_idx / 256, line)
                            emit_byte(name_idx % 256, line)
                            emit_byte(arg_count, line)
                        } else {
                            emit_byte(OP_INVOKE_GLOBAL, line)
                            emit_byte(receiver_slot, line)
                            emit_byte(name_idx, line)
                            emit_byte(arg_count, line)
                        }
                    } else {
                        emit_byte(OP_INVOKE, line)
                        emit_byte(name_idx, line)
                        emit_byte(arg_count, line)
                    } }
                } else {
                    // Optional method call: obj?.method(args)
                    // TOS = object. Check if nil.
                    let skip = emit_jump(OP_JUMP_IF_NOT_NIL, line)
                    // Is nil — push nil as result, skip method call
                    emit_byte(OP_POP, line)
                    emit_byte(OP_NIL, line)
                    let end_jump = emit_jump(OP_JUMP, line)
                    patch_jump(skip)
                    // Not nil — proceed with method call
                    advance()
                    flux arg_count = 0
                    if peek_type() != ")" {
                        parse_expression()
                        arg_count = arg_count + 1
                        while peek_type() == "," {
                            advance()
                            parse_expression()
                            arg_count = arg_count + 1
                        }
                    }
                    expect(nil, ")")
                    let name_idx = string_constant(field_name)
                    emit_byte(OP_INVOKE, line)
                    emit_byte(name_idx, line)
                    emit_byte(arg_count, line)
                    patch_jump(end_jump)
                }
            } else {
                // Field access
                if optional {
                    // Optional field access: obj?.field
                    let skip = emit_jump(OP_JUMP_IF_NOT_NIL, line)
                    let end_jump = emit_jump(OP_JUMP, line)
                    patch_jump(skip)
                    let name_idx = string_constant(field_name)
                    emit_bytes(OP_GET_FIELD, name_idx, line)
                    patch_jump(end_jump)
                } else {
                    let name_idx = string_constant(field_name)
                    emit_bytes(OP_GET_FIELD, name_idx, line)
                }
            }
        } else { if pt == "?" {
            // Try-propagate: expr? — unwrap ok or return err
            advance()
            emit_byte(OP_TRY_UNWRAP, line)
        } else {
            break
        } } } }
    }
}

fn is_struct_literal_ahead() {
    // After '{', check for 'ident :' or empty '}'
    if pos + 1 >= len(tokens) { return false }
    let next = tokens[pos + 1]
    if next.text == "}" { return true }
    if next.type != "identifier" { return false }
    if pos + 2 >= len(tokens) { return false }
    return tokens[pos + 2].text == ":"
}

fn parse_primary() {
    let line = current_line()
    let t = peek()

    if t == nil {
        compiler_error("unexpected end of input", line)
    }

    // Integer literal
    if t.type == "integer" {
        advance()
        let val = parse_int(t.text)
        if val >= -128 {
            if val <= 127 {
                if val < 0 {
                    emit_bytes(OP_LOAD_INT8, (val + 256) & 255, line)
                } else {
                    emit_bytes(OP_LOAD_INT8, val, line)
                }
                return
            }
        }
        emit_constant(make_int_const(val), line)
        return
    }

    // Float literal
    if t.type == "float" {
        advance()
        let val = parse_float(t.text)
        emit_constant(make_float_const(val), line)
        return
    }

    // String literal
    if t.type == "string" {
        advance()
        emit_constant(make_string_const(t.text), line)
        return
    }

    // String interpolation
    if t.type == "INTERP_START" {
        parse_string_interpolation()
        return
    }

    // Boolean literals
    if t.type == "true" {
        advance()
        emit_byte(OP_TRUE, line)
        return
    }
    if t.type == "false" {
        advance()
        emit_byte(OP_FALSE, line)
        return
    }

    // Nil literal
    if t.type == "nil" {
        advance()
        emit_byte(OP_NIL, line)
        return
    }

    // print(...) — special syntax
    if t.type == "print" {
        advance()
        expect(nil, "(")
        flux arg_count = 0
        if peek_text() != ")" {
            parse_expression()
            arg_count = arg_count + 1
            while peek_text() == "," {
                advance()
                parse_expression()
                arg_count = arg_count + 1
            }
        }
        expect(nil, ")")
        emit_bytes(OP_PRINT, arg_count, line)
        return
    }

    // if expression
    if t.type == "if" {
        parse_if_expression()
        return
    }

    // match expression
    if t.type == "match" {
        parse_match_expression()
        return
    }

    // scope expression
    if t.type == "scope" {
        parse_scope()
        return
    }

    // select expression
    if t.type == "identifier" && t.text == "select" && pos + 1 < len(tokens) && tokens[pos + 1].text == "{" {
        parse_select()
        return
    }

    // Closure literal: |params| { body }
    if t.type == "|" || t.text == "|" {
        parse_closure_literal()
        return
    }

    // Array literal [...]
    if t.text == "[" {
        advance()
        flux count = 0
        if peek_text() != "]" {
            parse_expression()
            count = count + 1
            while peek_text() == "," {
                advance()
                if peek_text() == "]" { break }
                parse_expression()
                count = count + 1
            }
        }
        expect(nil, "]")
        emit_bytes(OP_BUILD_ARRAY, count, line)
        return
    }

    // freeze/thaw/clone builtins
    if t.text == "freeze" || t.text == "thaw" || t.text == "clone" {
        if pos + 1 < len(tokens) && tokens[pos + 1].text == "(" {
            parse_freeze_thaw_clone(t.text, line)
            return
        }
    }

    // sublimate(expr) — keyword token
    if t.type == "sublimate" {
        if pos + 1 < len(tokens) && tokens[pos + 1].text == "(" {
            parse_sublimate_expr(line)
            return
        }
    }

    // anneal(expr) |v| { body } — keyword token
    if t.type == "anneal" {
        if pos + 1 < len(tokens) && tokens[pos + 1].text == "(" {
            parse_anneal_expr(line)
            return
        }
    }

    // crystallize(expr) { body } — keyword token
    if t.type == "crystallize" {
        if pos + 1 < len(tokens) && tokens[pos + 1].text == "(" {
            parse_crystallize_expr(line)
            return
        }
    }

    // Phase system special forms: react/unreact/bond/unbond/seed/unseed
    if t.type == "identifier" {
        if t.text == "react" && pos + 1 < len(tokens) && tokens[pos + 1].text == "(" {
            parse_react_call(line)
            return
        }
        if t.text == "unreact" && pos + 1 < len(tokens) && tokens[pos + 1].text == "(" {
            parse_unreact_call(line)
            return
        }
        if t.text == "bond" && pos + 1 < len(tokens) && tokens[pos + 1].text == "(" {
            parse_bond_call(line)
            return
        }
        if t.text == "unbond" && pos + 1 < len(tokens) && tokens[pos + 1].text == "(" {
            parse_unbond_call(line)
            return
        }
        if t.text == "seed" && pos + 1 < len(tokens) && tokens[pos + 1].text == "(" {
            parse_seed_call(line)
            return
        }
        if t.text == "unseed" && pos + 1 < len(tokens) && tokens[pos + 1].text == "(" {
            parse_unseed_call(line)
            return
        }
    }

    // Identifier
    if t.type == "identifier" {
        advance()
        // Check for struct construction: Name { ... }
        if peek_text() == "{" && is_struct_literal_ahead() {
            let first_char = t.text[0]
            if first_char != nil {
                let c = ord(first_char)
                if c >= 65 {
                    if c <= 90 {
                        parse_struct_literal(t.text, line)
                        return
                    }
                }
            }
        }
        // Namespaced: Foo::bar(...)
        if peek_text() == "::" {
            advance()
            let method_name = expect("identifier", nil).text
            // Check if this is a known enum
            let is_enum = false
            for ei in 0..len(known_enums) {
                if known_enums[ei] == t.text {
                    is_enum = true
                    break
                }
            }
            if is_enum {
                // Emit args if present
                flux arg_count = 0
                if peek_text() == "(" {
                    advance()
                    if peek_text() != ")" {
                        parse_expression()
                        arg_count = arg_count + 1
                        while peek_text() == "," {
                            advance()
                            parse_expression()
                            arg_count = arg_count + 1
                        }
                    }
                    expect(nil, ")")
                }
                let enum_idx = string_constant(t.text)
                let var_idx = string_constant(method_name)
                emit_byte(OP_BUILD_ENUM, line)
                emit_byte(enum_idx, line)
                emit_byte(var_idx, line)
                emit_byte(arg_count, line)
                return
            }
            let full_name = t.text + "::" + method_name
            emit_variable_get(full_name, line)
            return
        }
        emit_variable_get(t.text, line)
        return
    }

    // Parenthesized expression
    if t.text == "(" {
        advance()
        parse_expression()
        expect(nil, ")")
        return
    }

    compiler_error("unexpected token '" + t.text + "' (type: " + t.type + ")", line)
}

fn emit_var_loc(name: any, line: any) {
    // Emit the 2-byte loc_type + slot for a variable name (used by phase opcodes)
    let slot = resolve_local(name)
    if slot >= 0 {
        emit_byte(0, line)
        emit_byte(slot, line)
        return
    }
    let up = resolve_upvalue(name)
    if up >= 0 {
        emit_byte(1, line)
        emit_byte(up, line)
        return
    }
    emit_byte(2, line)
    emit_byte(0, line)
}

fn parse_freeze_thaw_clone(keyword: any, line: any) {
    advance()  // consume keyword (freeze/thaw/clone)
    expect(nil, "(")

    // Check what's inside the parens — is it a simple identifier?
    let check_tok = peek()
    flux is_simple_ident = false
    let ident_name = ""
    if check_tok != nil {
        if check_tok.type == "identifier" {
            if pos + 1 < len(tokens) {
                if tokens[pos + 1].text == ")" {
                    is_simple_ident = true
                    ident_name = check_tok.text
                }
            }
        }
    }

    // Check for freeze(obj.field) — field access inside freeze
    flux is_field_access = false
    flux field_parent = ""
    flux field_name_str = ""
    if keyword == "freeze" {
        if !is_simple_ident {
            if check_tok != nil {
                if check_tok.type == "identifier" {
                    if pos + 3 < len(tokens) {
                        if tokens[pos + 1].text == "." {
                            if tokens[pos + 2].type == "identifier" {
                                if tokens[pos + 3].text == ")" {
                                    is_field_access = true
                                    field_parent = check_tok.text
                                    field_name_str = tokens[pos + 2].text
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Check for freeze(obj[key]) — index access inside freeze
    flux is_index_access = false
    flux index_parent = ""
    if keyword == "freeze" {
        if !is_simple_ident {
            if !is_field_access {
                if check_tok != nil {
                    if check_tok.type == "identifier" {
                        if pos + 1 < len(tokens) {
                            if tokens[pos + 1].text == "[" {
                                is_index_access = true
                                index_parent = check_tok.text
                            }
                        }
                    }
                }
            }
        }
    }

    if is_field_access {
        // freeze(obj.field) -> OP_FREEZE_FIELD
        advance()  // obj
        advance()  // .
        advance()  // field
        expect(nil, ")")
        emit_constant(make_string_const(field_name_str), line)
        let pname_idx = string_constant(field_parent)
        emit_byte(OP_FREEZE_FIELD, line)
        emit_byte(pname_idx, line)
        emit_var_loc(field_parent, line)
        return
    }

    if is_index_access {
        // freeze(obj[key]) -> parse obj, skip, parse key, OP_FREEZE_FIELD
        advance()  // skip obj identifier
        advance()  // skip '['
        parse_expression()
        expect(nil, "]")
        expect(nil, ")")
        let pname_idx = string_constant(index_parent)
        emit_byte(OP_FREEZE_FIELD, line)
        emit_byte(pname_idx, line)
        emit_var_loc(index_parent, line)
        return
    }

    parse_expression()
    expect(nil, ")")

    if keyword == "clone" {
        emit_byte(OP_CLONE, line)
        return
    }

    // Check for freeze(x) except ["field1", "field2"]
    if keyword == "freeze" {
        if is_simple_ident {
            let next_tok = peek()
            if next_tok != nil {
                if next_tok.type == "identifier" {
                    if next_tok.text == "except" {
                        advance()  // consume 'except'
                        expect(nil, "[")
                        flux except_count = 0
                        while peek_text() != "]" {
                            parse_expression()
                            except_count = except_count + 1
                            if peek_text() == "," { advance() }
                        }
                        expect(nil, "]")
                        let name_idx = string_constant(ident_name)
                        emit_byte(OP_FREEZE_EXCEPT, line)
                        emit_byte(name_idx, line)
                        emit_var_loc(ident_name, line)
                        emit_byte(except_count, line)
                        return
                    }
                }
            }
        }
    }

    if is_simple_ident {
        let name_idx = string_constant(ident_name)
        if keyword == "freeze" {
            emit_byte(OP_FREEZE_VAR, line)
        } else {
            emit_byte(OP_THAW_VAR, line)
        }
        emit_byte(name_idx, line)
        emit_var_loc(ident_name, line)
    } else {
        if keyword == "freeze" {
            emit_byte(OP_FREEZE, line)
        } else {
            emit_byte(OP_THAW, line)
        }
    }
}

// ============================================================================
// Section 8d: Phase system expression parsing
// ============================================================================

fn parse_sublimate_expr(line: any) {
    advance()  // consume 'sublimate'
    expect(nil, "(")

    let is_simple_ident = peek_type() == "identifier" && pos + 1 < len(tokens) && tokens[pos + 1].text == ")"
    let ident_name = ""
    if is_simple_ident {
        ident_name = peek_text()
    }

    parse_expression()
    expect(nil, ")")

    if is_simple_ident {
        let name_idx = string_constant(ident_name)
        emit_byte(OP_SUBLIMATE_VAR, line)
        emit_byte(name_idx, line)
        emit_var_loc(ident_name, line)
    } else {
        emit_byte(OP_SUBLIMATE, line)
    }
}

fn parse_anneal_expr(line: any) {
    // anneal(target) |v| { body }
    // Phase check: target must be crystal. Thaw, call closure, refreeze.
    advance()  // consume 'anneal'
    expect(nil, "(")

    let is_ident = peek_type() == "identifier" && pos + 1 < len(tokens) && tokens[pos + 1].text == ")"
    let ident_name = ""
    if is_ident {
        ident_name = peek_text()
    }

    parse_expression()  // target value
    expect(nil, ")")

    // Phase check: target must be crystal
    emit_byte(OP_IS_CRYSTAL, line)
    let anneal_ok = emit_jump(OP_JUMP_IF_FALSE, line)
    emit_byte(OP_POP, line)  // pop true
    let anneal_past_check = emit_jump(OP_JUMP, line)
    patch_jump(anneal_ok)
    emit_byte(OP_POP, line)  // pop false
    emit_constant(make_string_const("anneal requires a crystal value"), line)
    emit_byte(OP_THROW, line)
    patch_jump(anneal_past_check)

    // Wrap in try/catch for error prefix
    let anneal_handler = emit_jump(OP_PUSH_EXCEPTION_HANDLER, line)

    // Parse closure expression: |v| { ... }
    parse_expression()  // closure value

    // Now: stack = [closure]. Push target, thaw, call closure(thawed).
    if is_ident {
        emit_variable_get(ident_name, line)
    } else {
        // For non-ident targets, we can't re-evaluate. Just use THAW on stack.
        // This is a limitation; non-ident anneal isn't fully supported.
        emit_byte(OP_NIL, line)
    }
    emit_byte(OP_THAW, line)
    emit_bytes(OP_CALL, 1, line)

    // Refreeze the target if it's an identifier
    if is_ident {
        let name_idx = string_constant(ident_name)
        emit_byte(OP_FREEZE_VAR, line)
        emit_byte(name_idx, line)
        emit_var_loc(ident_name, line)
    } else {
        emit_byte(OP_FREEZE, line)
    }

    // End of try block
    emit_byte(OP_POP_EXCEPTION_HANDLER, line)
    let anneal_end = emit_jump(OP_JUMP, line)

    // Catch block: wrap error with "anneal failed: " prefix
    patch_jump(anneal_handler)
    emit_constant(make_string_const("anneal failed: "), line)
    emit_byte(OP_SWAP, line)
    emit_byte(OP_CONCAT, line)
    emit_byte(OP_THROW, line)

    patch_jump(anneal_end)
}

fn parse_crystallize_expr(line: any) {
    // crystallize(target) { body }
    // Freeze target, run body, conditionally thaw (if wasn't already crystal).
    advance()  // consume 'crystallize'
    expect(nil, "(")

    let is_ident = peek_type() == "identifier" && pos + 1 < len(tokens) && tokens[pos + 1].text == ")"
    let ident_name = ""
    if is_ident {
        ident_name = peek_text()
    }

    parse_expression()  // target value
    expect(nil, ")")

    if is_ident {
        let name_idx = string_constant(ident_name)
        // Check if already crystal — save result as a local
        begin_scope()
        emit_variable_get(ident_name, line)
        emit_byte(OP_IS_CRYSTAL, line)
        add_local("")  // was_crystal flag
        let flag_slot = local_count - 1

        // Freeze the variable
        emit_variable_get(ident_name, line)
        emit_byte(OP_FREEZE_VAR, line)
        emit_byte(name_idx, line)
        emit_var_loc(ident_name, line)
        emit_byte(OP_POP, line)  // discard freeze result

        // Execute body
        expect(nil, "{")
        while peek_text() != "}" {
            if peek() == nil {
                compiler_error("unexpected end of input in crystallize body", line)
            }
            parse_statement_or_expression()
        }
        expect(nil, "}")

        // Conditional thaw: only if was NOT already crystal
        emit_bytes(OP_GET_LOCAL, flag_slot, line)
        let skip_thaw = emit_jump(OP_JUMP_IF_FALSE, line)
        // was_crystal=true -> skip thaw
        emit_byte(OP_POP, line)
        let past_thaw = emit_jump(OP_JUMP, line)
        // was_crystal=false -> do thaw
        patch_jump(skip_thaw)
        emit_byte(OP_POP, line)
        emit_variable_get(ident_name, line)
        emit_byte(OP_THAW_VAR, line)
        emit_byte(name_idx, line)
        emit_var_loc(ident_name, line)
        emit_byte(OP_POP, line)
        patch_jump(past_thaw)
        end_scope(line)
        emit_byte(OP_UNIT, line)
    } else {
        // Fallback: just freeze the expression
        emit_byte(OP_FREEZE, line)
    }
}

fn parse_react_call(line: any) {
    // react(var, callback) -> compile callback, OP_REACT var_name_idx
    advance()  // consume 'react'
    expect(nil, "(")
    let var_name = expect("identifier", nil).text
    expect(nil, ",")
    parse_expression()  // callback
    expect(nil, ")")
    let idx = string_constant(var_name)
    emit_bytes(OP_REACT, idx, line)
}

fn parse_unreact_call(line: any) {
    // unreact(var) -> OP_UNREACT var_name_idx
    advance()  // consume 'unreact'
    expect(nil, "(")
    let var_name = expect("identifier", nil).text
    expect(nil, ")")
    let idx = string_constant(var_name)
    emit_bytes(OP_UNREACT, idx, line)
}

fn parse_bond_call(line: any) {
    // bond(target, dep1, dep2, ..., [strategy_string])
    advance()  // consume 'bond'
    expect(nil, "(")
    let target_name = expect("identifier", nil).text
    let target_idx = string_constant(target_name)

    // Collect remaining args (identifiers and optional trailing string)
    flux dep_names = []
    flux strategy = "freeze"
    while peek_text() == "," {
        advance()
        if peek_type() == "string" {
            // Last arg is a strategy string
            strategy = advance().text
        } else {
            let dep = expect("identifier", nil).text
            dep_names.push(dep)
        }
    }
    expect(nil, ")")

    // Emit one OP_BOND per dependency
    let dep_count = len(dep_names)
    flux i = 0
    while i < dep_count {
        let dep_idx = string_constant(dep_names[i])
        emit_bytes(OP_CONSTANT, dep_idx, line)
        let strat_idx = string_constant(strategy)
        emit_bytes(OP_CONSTANT, strat_idx, line)
        emit_bytes(OP_BOND, target_idx, line)
        if i + 1 < dep_count {
            emit_byte(OP_POP, line)
        }
        i = i + 1
    }
}

fn parse_unbond_call(line: any) {
    // unbond(target, dep1, dep2, ...)
    advance()  // consume 'unbond'
    expect(nil, "(")
    let target_name = expect("identifier", nil).text
    let target_idx = string_constant(target_name)

    flux dep_names = []
    while peek_text() == "," {
        advance()
        let dep = expect("identifier", nil).text
        dep_names.push(dep)
    }
    expect(nil, ")")

    let dep_count = len(dep_names)
    flux i = 0
    while i < dep_count {
        let dep_idx = string_constant(dep_names[i])
        emit_bytes(OP_CONSTANT, dep_idx, line)
        emit_bytes(OP_UNBOND, target_idx, line)
        if i + 1 < dep_count {
            emit_byte(OP_POP, line)
        }
        i = i + 1
    }
}

fn parse_seed_call(line: any) {
    // seed(var, callback) -> compile callback, OP_SEED var_name_idx
    advance()  // consume 'seed'
    expect(nil, "(")
    let var_name = expect("identifier", nil).text
    expect(nil, ",")
    parse_expression()  // callback
    expect(nil, ")")
    let idx = string_constant(var_name)
    emit_bytes(OP_SEED, idx, line)
}

fn parse_unseed_call(line: any) {
    // unseed(var) -> OP_UNSEED var_name_idx
    advance()  // consume 'unseed'
    expect(nil, "(")
    let var_name = expect("identifier", nil).text
    expect(nil, ")")
    let idx = string_constant(var_name)
    emit_bytes(OP_UNSEED, idx, line)
}

fn parse_struct_literal(name: any, line: any) {
    expect(nil, "{")
    flux field_names_arr = []
    flux field_count = 0
    if peek_text() != "}" {
        let fname = expect("identifier", nil).text
        expect(nil, ":")
        parse_expression()
        field_names_arr.push(fname)
        field_count = field_count + 1
        while peek_text() == "," {
            advance()
            if peek_text() == "}" { break }
            let fn2 = expect("identifier", nil).text
            expect(nil, ":")
            parse_expression()
            field_names_arr.push(fn2)
            field_count = field_count + 1
        }
    }
    expect(nil, "}")
    let name_idx = string_constant(name)
    emit_byte(OP_BUILD_STRUCT, line)
    emit_byte(name_idx, line)
    emit_byte(field_count, line)
    for i in 0..field_count {
        add_constant(make_string_const(field_names_arr[i]))
    }
}

fn parse_string_interpolation() {
    let line = current_line()
    let start = advance()
    emit_constant(make_string_const(start.text), line)

    parse_expression()
    emit_variable_get("to_string", line)
    emit_byte(OP_SWAP, line)
    emit_bytes(OP_CALL, 1, line)
    emit_byte(OP_CONCAT, line)

    while peek_type() == "INTERP_MID" {
        let mid = advance()
        emit_constant(make_string_const(mid.text), line)
        emit_byte(OP_CONCAT, line)
        parse_expression()
        emit_variable_get("to_string", line)
        emit_byte(OP_SWAP, line)
        emit_bytes(OP_CALL, 1, line)
        emit_byte(OP_CONCAT, line)
    }

    if peek_type() == "INTERP_END" {
        let end_tok = advance()
        if len(end_tok.text) > 0 {
            emit_constant(make_string_const(end_tok.text), line)
            emit_byte(OP_CONCAT, line)
        }
    }
}

fn parse_if_expression() {
    let line = current_line()
    expect("if", nil)
    parse_expression()
    let then_jump = emit_jump(OP_JUMP_IF_FALSE, line)
    emit_byte(OP_POP, line)

    if peek_text() == "{" {
        parse_block_expression()
    } else {
        parse_expression()
    }

    let else_jump = emit_jump(OP_JUMP, line)
    patch_jump(then_jump)
    emit_byte(OP_POP, line)

    if peek_text() == "else" {
        advance()
        if peek_text() == "if" {
            parse_if_expression()
        } else { if peek_text() == "{" {
            parse_block_expression()
        } else {
            parse_expression()
        } }
    } else {
        emit_byte(OP_NIL, line)
    }
    patch_jump(else_jump)
}

fn parse_match_expression() {
    let line = current_line()
    advance()  // consume 'match'
    parse_expression()  // scrutinee -> on stack
    expect(nil, "{")

    flux end_jumps = []

    while peek_text() != "}" {
        if peek() == nil {
            compiler_error("unexpected end of input in match", line)
        }

        // Determine pattern type by lookahead
        // Binding pattern: identifier (not "_") followed by "if" or "=>"
        // Range pattern: integer ".." integer
        // Wildcard: "_"
        // Literal: string, integer, float, true, false, nil

        let pat_tok = peek()
        flux is_binding = false
        flux is_range = false
        flux is_enum_destructure = false

        if pat_tok.type == "identifier" && pat_tok.text != "_" {
            // Check for enum variant destructuring: Ident::Ident(bindings...)
            // This must be checked BEFORE binding detection so that
            // e.g. Option::Some(x) is not mis-classified as a binding on "Option".
            if pos + 2 < len(tokens) && tokens[pos + 1].text == "::" && tokens[pos + 2].type == "identifier" {
                // Ident::Ident — check if followed by "(" (destructuring) or "=>" / "if" (plain enum match)
                if pos + 3 < len(tokens) && tokens[pos + 3].text == "(" {
                    is_enum_destructure = true
                }
                // If not destructuring, the enum variant pattern (e.g. Color::Red)
                // falls through to the non-binding path where parse_expression()
                // handles it as an expression comparison.
            }

            if !is_enum_destructure {
                // An identifier that isn't _ is a binding pattern
                // (it binds the scrutinee to a name, optionally with a guard)
                if pos + 1 < len(tokens) {
                    let next_tok = tokens[pos + 1]
                    if next_tok.text == "if" || next_tok.text == "=>" {
                        is_binding = true
                    }
                }
            }
        }

        if !is_binding && !is_enum_destructure && pat_tok.type == "integer" {
            // Check for range pattern: int..int
            if pos + 1 < len(tokens) && tokens[pos + 1].type == ".." {
                is_range = true
            }
        }

        if is_enum_destructure {
            // === Enum variant destructuring pattern ===
            // Pattern: EnumName::Variant(binding1, binding2, ...)
            // Stack invariant: scrutinee S stays on stack across arms.
            //
            // Approach:
            //   DUP S -> [S, S'].
            //   DUP S' -> [S, S', S''].
            //   Invoke .tag on S'' -> [S, S', tag_string].
            //   Compare tag with variant_name -> [S, S', bool].
            //   If false: pop bool + pop S' -> [S], next arm.
            //   If true: pop bool. S' is the matched enum value.
            //     Register S' as local. Extract payload into bindings.
            //     Compile body -> result. Clean up bindings + S' + S.
            //     Jump to end.

            let ed_enum_name = advance().text     // consume EnumName
            advance()                              // consume '::'
            let ed_variant_name = advance().text   // consume Variant
            advance()                              // consume '('

            // Parse binding names
            flux bind_names = []
            if peek_text() != ")" {
                bind_names.push(expect("identifier", nil).text)
                while peek_text() == "," {
                    advance()
                    if peek_text() == ")" { break }
                    bind_names.push(expect("identifier", nil).text)
                }
            }
            expect(nil, ")")

            let bind_count = len(bind_names)

            // Stack: [S]
            emit_byte(OP_DUP, line)   // [S, S']
            emit_byte(OP_DUP, line)   // [S, S', S'']

            // Get the tag: invoke .tag on S''
            let tag_idx = string_constant("tag")
            emit_byte(OP_INVOKE, line)
            emit_byte(tag_idx, line)
            emit_byte(0, line)  // 0 args
            // Stack: [S, S', tag_string]

            // Compare tag with variant name
            emit_constant(make_string_const(ed_variant_name), line)
            // Stack: [S, S', tag_string, variant_name_const]
            emit_byte(OP_EQ, line)
            // Stack: [S, S', bool]

            let next_arm = emit_jump(OP_JUMP_IF_FALSE, line)
            emit_byte(OP_POP, line)  // pop true: [S, S']

            // Tag matched! Open a scope for S' and bindings.
            begin_scope()
            add_local("")  // dummy slot for scrutinee S on stack
            add_local("")  // S' (the matched enum value)

            // Extract payload elements as local bindings.
            // For each binding: GET_LOCAL(enum_slot) -> .payload -> [i] -> add_local
            let enum_slot = local_count - 1
            for bi in 0..bind_count {
                emit_bytes(OP_GET_LOCAL, enum_slot, line)
                let payload_idx = string_constant("payload")
                emit_byte(OP_INVOKE, line)
                emit_byte(payload_idx, line)
                emit_byte(0, line)  // 0 args -> returns payload array
                emit_constant(make_int_const(bi), line)
                emit_byte(OP_INDEX, line)
                add_local(bind_names[bi])
            }

            expect(nil, "=>")

            // Compile arm body in a nested scope
            begin_scope()
            if peek_text() == "{" {
                expect(nil, "{")
                flux match_last_expr = false
                while peek_text() != "}" {
                    if peek() == nil {
                        compiler_error("unexpected end of input in match arm block", line)
                    }
                    if match_last_expr {
                        emit_byte(OP_POP, line)
                    }
                    match_last_expr = false
                    if is_statement_start() {
                        parse_statement()
                    } else {
                        parse_expression()
                        match_last_expr = true
                    }
                }
                expect(nil, "}")
                if match_last_expr {
                    end_scope_preserve_tos(line)
                } else {
                    end_scope(line)
                    emit_byte(OP_UNIT, line)
                }
            } else {
                parse_expression()
                end_scope_preserve_tos(line)
            }

            // Stack: [S(dummy), S'(enum), bind1...bindN, result]
            // Swap result past each local and pop it
            flux pi = 0
            while pi < bind_count + 1 {
                emit_byte(OP_SWAP, line)
                emit_byte(OP_POP, line)
                pi = pi + 1
            }
            // Stack: [S, result]
            emit_byte(OP_SWAP, line)  // [result, S]
            emit_byte(OP_POP, line)   // [result]

            // Remove locals from compiler without emitting more pops
            scope_depth = scope_depth - 1
            while local_count > 0 && local_depth_arr[local_count - 1] > scope_depth {
                local_count = local_count - 1
            }

            end_jumps.push(emit_jump(OP_JUMP, line))

            patch_jump(next_arm)
            // JUMP_IF_FALSE doesn't pop: [S, S', false]
            emit_byte(OP_POP, line)  // pop false: [S, S']
            emit_byte(OP_POP, line)  // pop S': [S]

        } else { if is_binding {
            // === Binding pattern ===
            // Stack invariant: scrutinee S stays on stack.
            // DUP S -> [S, S']. S' becomes local binding.
            // Guard references the binding. On match: body produces result,
            // then we clean up the scope. On no match: pop guard_bool, pop n -> [S].
            let binding_name = advance().text  // consume identifier

            begin_scope()
            add_local("")  // dummy slot tracks scrutinee S
            emit_byte(OP_DUP, line)  // [S, S']
            add_local(binding_name)

            // Compile guard (or TRUE if none)
            if peek_text() == "if" {
                advance()  // consume 'if'
                parse_expression()  // [S, n, guard_bool]
            } else {
                emit_byte(OP_TRUE, line)  // [S, n, true]
            }

            let next_arm = emit_jump(OP_JUMP_IF_FALSE, line)
            emit_byte(OP_POP, line)  // pop bool: [S, n]

            expect(nil, "=>")

            // Compile arm body in a nested scope so body-locals
            // are cleaned up before the binding variable.
            begin_scope()
            if peek_text() == "{" {
                expect(nil, "{")
                flux match_last_expr = false
                while peek_text() != "}" {
                    if peek() == nil {
                        compiler_error("unexpected end of input in match arm block", line)
                    }
                    if match_last_expr {
                        emit_byte(OP_POP, line)
                    }
                    match_last_expr = false
                    if is_statement_start() {
                        parse_statement()
                    } else {
                        parse_expression()
                        match_last_expr = true
                    }
                }
                expect(nil, "}")
                if match_last_expr {
                    end_scope_preserve_tos(line)
                } else {
                    end_scope(line)
                    emit_byte(OP_UNIT, line)
                }
            } else {
                parse_expression()
                end_scope_preserve_tos(line)
            }

            // Stack: [S(dummy), n(binding), result]
            // Swap result past n, then pop n and S via manual cleanup
            emit_byte(OP_SWAP, line)  // [S, result, n]
            emit_byte(OP_POP, line)   // [S, result] — pop n
            emit_byte(OP_SWAP, line)  // [result, S]
            emit_byte(OP_POP, line)   // [result] — pop S
            // Remove locals from compiler without emitting more pops
            scope_depth = scope_depth - 1
            while local_count > 0 && local_depth_arr[local_count - 1] > scope_depth {
                local_count = local_count - 1
            }

            end_jumps.push(emit_jump(OP_JUMP, line))

            patch_jump(next_arm)
            // JUMP_IF_FALSE doesn't pop: [S, n, false]
            emit_byte(OP_POP, line)  // pop false: [S, n]
            emit_byte(OP_POP, line)  // pop n: [S]
            // scope_depth and local_count already cleaned in match path above
        } else {
            // === Non-binding pattern: LITERAL, WILDCARD, RANGE ===
            emit_byte(OP_DUP, line)  // [S, S']

            let is_wildcard = peek_text() == "_"

            if is_wildcard {
                advance()
                emit_byte(OP_TRUE, line)  // [S, S', true]
            } else { if is_range {
                // Range pattern: int..int
                // DUP S', compare >= start, if false skip to end,
                // else DUP S' again, compare <= end
                emit_byte(OP_DUP, line)  // [S, S', S'']
                let range_start = advance()  // consume start integer
                let start_val = parse_int(range_start.text)
                emit_constant(make_int_const(start_val), line)
                emit_byte(OP_GTEQ, line)  // [S, S', start_ok]
                let range_fail = emit_jump(OP_JUMP_IF_FALSE, line)
                emit_byte(OP_POP, line)  // pop true
                advance()  // consume '..'
                emit_byte(OP_DUP, line)  // [S, S', S'']
                let range_end = advance()  // consume end integer
                let end_val = parse_int(range_end.text)
                emit_constant(make_int_const(end_val), line)
                emit_byte(OP_LTEQ, line)  // [S, S', end_ok]
                let range_done = emit_jump(OP_JUMP, line)
                patch_jump(range_fail)
                // range_fail lands here with [S, S', false] on stack
                patch_jump(range_done)
            } else {
                emit_byte(OP_DUP, line)  // [S, S', S''] — extra dup for OP_EQ consumption
                // Parse pattern as literal directly
                let pat = peek()
                if pat.type == "string" {
                    advance()
                    emit_constant(make_string_const(pat.text), line)
                } else { if pat.type == "integer" {
                    advance()
                    let val = parse_int(pat.text)
                    emit_constant(make_int_const(val), line)
                } else { if pat.type == "float" {
                    advance()
                    let val = parse_float(pat.text)
                    emit_constant(make_float_const(val), line)
                } else { if pat.type == "true" {
                    advance()
                    emit_byte(OP_TRUE, line)
                } else { if pat.type == "false" {
                    advance()
                    emit_byte(OP_FALSE, line)
                } else { if pat.type == "nil" {
                    advance()
                    emit_byte(OP_NIL, line)
                } else { if pat.text == "-" {
                    // Negative literal
                    advance()  // consume '-'
                    let neg_pat = peek()
                    if neg_pat.type == "integer" {
                        advance()
                        let val = parse_int(neg_pat.text)
                        emit_constant(make_int_const(0 - val), line)
                    } else { if neg_pat.type == "float" {
                        advance()
                        let val = parse_float(neg_pat.text)
                        emit_constant(make_float_const(0.0 - val), line)
                    } else {
                        compiler_error("expected number after '-' in pattern", line)
                    } }
                } else {
                    parse_expression()
                } } } } } } }
                emit_byte(OP_EQ, line)  // [S, S', bool]
            } }

            // Guard: if present, chain with pattern check
            if peek_text() == "if" {
                advance()  // consume 'if'
                let guard_skip = emit_jump(OP_JUMP_IF_FALSE, line)
                emit_byte(OP_POP, line)
                parse_expression()
                let guard_done = emit_jump(OP_JUMP, line)
                patch_jump(guard_skip)
                patch_jump(guard_done)
            }

            let next_arm = emit_jump(OP_JUMP_IF_FALSE, line)

            // Match succeeded: pop bool, pop S', pop S
            emit_byte(OP_POP, line)
            emit_byte(OP_POP, line)
            emit_byte(OP_POP, line)

            expect(nil, "=>")
            if peek_text() == "{" {
                parse_block_expression()
            } else {
                parse_expression()
            }

            end_jumps.push(emit_jump(OP_JUMP, line))

            // Match failed: patch here, pop bool + pop S'
            patch_jump(next_arm)
            emit_byte(OP_POP, line)  // pop false
            emit_byte(OP_POP, line)  // pop S'
        } }

        // Optional trailing comma
        if peek_text() == "," {
            advance()
        }
    }
    expect(nil, "}")

    // No match fallback: pop scrutinee, push nil
    emit_byte(OP_POP, line)
    emit_byte(OP_NIL, line)

    // Patch all end jumps to here
    for i in 0..len(end_jumps) {
        patch_jump(end_jumps[i])
    }
}

fn parse_block_expression() {
    let line = current_line()
    expect(nil, "{")
    begin_scope()
    flux last_was_expr = false

    while peek_text() != "}" {
        if peek() == nil {
            compiler_error("unexpected end of input, expected '}'", line)
        }
        if last_was_expr {
            emit_byte(OP_POP, line)
        }
        last_was_expr = false

        if is_statement_start() {
            parse_statement()
        } else {
            parse_expression()
            last_was_expr = true
        }
    }
    expect(nil, "}")
    if last_was_expr {
        end_scope_preserve_tos(line)
    } else {
        end_scope(line)
        emit_byte(OP_NIL, line)
    }
}

fn parse_closure_literal() {
    let line = current_line()
    expect(nil, "|")

    flux param_names_arr = []
    if peek_text() != "|" {
        let p = expect("identifier", nil).text
        // Consume optional type annotation
        if peek_text() == ":" {
            advance()
            expect("identifier", nil)
        }
        param_names_arr.push(p)
        while peek_text() == "," {
            advance()
            let p2 = expect("identifier", nil).text
            // Consume optional type annotation
            if peek_text() == ":" {
                advance()
                expect("identifier", nil)
            }
            param_names_arr.push(p2)
        }
    }
    expect(nil, "|")

    let param_count = len(param_names_arr)
    save_compiler()

    code = []
    c_lines = []
    constants = []
    local_names = []
    local_name_arr = []
    local_depth_arr = []
    local_captured_arr = []
    local_count = 0
    scope_depth = 0
    upvalue_index_arr = []
    upvalue_islocal_arr = []
    upvalue_count = 0
    func_type = "function"
    break_jumps = []
    break_count = 0
    loop_start_pos = 0
    loop_depth = 0
    string_intern_map = Map::new()

    // Reserve slot 0 for the closure itself (VM convention)
    add_local("")
    begin_scope()
    for i in 0..param_count {
        add_local(param_names_arr[i])
    }

    if peek_text() == "{" {
        expect(nil, "{")
        flux last_was_expr = false
        while peek_text() != "}" {
            if peek() == nil {
                compiler_error("unexpected end of input in closure body", line)
            }
            if last_was_expr {
                emit_byte(OP_POP, line)
            }
            last_was_expr = false
            if is_statement_start() {
                parse_statement()
            } else {
                parse_expression()
                last_was_expr = true
            }
        }
        expect(nil, "}")
        if !last_was_expr {
            emit_byte(OP_UNIT, line)
        }
    } else {
        parse_expression()
    }

    emit_byte(OP_DEFER_RUN, line)
    emit_byte(0, line)  // scope_depth 0 = run all defers
    emit_byte(OP_RETURN, line)

    let fn_snap = snapshot_chunk()
    let fn_uv_idx = upvalue_index_arr
    let fn_uv_loc = upvalue_islocal_arr
    let fn_uv_count = upvalue_count

    restore_compiler()

    let fn_const = make_closure_const(param_count, false, fn_snap)
    let fn_idx = add_constant(fn_const)

    emit_wide_op(OP_CLOSURE, OP_CLOSURE_16, fn_idx, line)
    emit_byte(fn_uv_count, line)
    flux i = 0
    while i < fn_uv_count {
        if fn_uv_loc[i] {
            emit_byte(1, line)
        } else {
            emit_byte(0, line)
        }
        emit_byte(fn_uv_idx[i], line)
        i = i + 1
    }
}

// ============================================================================
// Section 8b: Sub-chunk compilation helpers
// ============================================================================

// Initialize a fresh, detached compiler state for sub-chunk compilation.
// Call save_compiler() first, then this. This also detaches from the
// compiler_stack so that resolve_upvalue won't find enclosing locals
// (sub-chunks should reference outer variables as globals, not upvalues).
// Returns the saved compiler_stack so it can be restored after.
fn init_sub_compiler() {
    let saved_stack = compiler_stack
    compiler_stack = []
    code = []
    c_lines = []
    constants = []
    local_names = []
    local_name_arr = []
    local_depth_arr = []
    local_captured_arr = []
    local_count = 0
    scope_depth = 0
    upvalue_index_arr = []
    upvalue_islocal_arr = []
    upvalue_count = 0
    func_type = "script"
    break_jumps = []
    break_count = 0
    loop_start_pos = 0
    loop_depth = 0
    string_intern_map = Map::new()
    ensure_slots = []
    ensure_messages = []
    ensure_count = 0
    current_func_name = ""
    return saved_stack
}

// Compile a single expression as a sub-chunk. Returns constant index.
fn compile_sub_expr_chunk(line: any) {
    save_compiler()
    let saved_stack = init_sub_compiler()

    parse_expression()
    emit_byte(OP_RETURN, line)

    let snap = snapshot_chunk()
    compiler_stack = saved_stack
    restore_compiler()

    let fn_const = make_closure_const(0, false, snap)
    return add_constant(fn_const)
}

// ============================================================================
// Section 8c: Scope / Select parsing
// ============================================================================

fn parse_scope() {
    let line = current_line()
    advance()  // consume 'scope'
    expect(nil, "{")

    // We need to collect spawn bodies and sync (non-spawn) bodies.
    // Strategy: parse the body, tracking which items are spawn blocks.
    // Each spawn block and the collected sync statements become sub-chunks.
    flux spawn_indices = []
    flux sync_positions = []
    flux items = []  // array of [is_spawn, start_pos, end_pos]

    // First pass: scan the scope body to identify spawn blocks and non-spawn statements.
    // We'll use a token-scanning approach to find spawn { ... } blocks.
    flux body_start = pos
    flux brace_depth = 0
    while peek_text() != "}" || brace_depth > 0 {
        if peek() == nil {
            compiler_error("unexpected end of input in scope body", line)
        }
        let ct = peek_text()
        if ct == "{" { brace_depth = brace_depth + 1 }
        if ct == "}" { brace_depth = brace_depth - 1 }
        advance()
    }
    let body_end = pos

    // Reset to body_start and compile each item
    pos = body_start

    flux spawn_count = 0
    flux sync_stmt_start_positions = []

    // Second approach: directly compile, categorizing as we go.
    // When we see 'spawn' token followed by '{', compile it as a spawn sub-chunk.
    // Otherwise, remember non-spawn statement positions for the sync chunk.
    // Since the sub-chunk compilation uses save/restore which resets parsing state,
    // we need a different approach: scan first, then compile.

    // Approach: Two-pass within the scope body.
    // Pass 1: identify spawn boundaries and non-spawn statement boundaries.
    // This is complex without AST. Instead, let's use a simpler approach:
    // compile all spawn bodies as sub-chunks, collect non-spawn as sync sub-chunk.

    // Simplest approach matching C compiler:
    // - Scan the body once, identifying spawn blocks (spawn { ... }) and non-spawn items
    // - For each spawn block: save pos, compile as sub-chunk
    // - For sync body: collect non-spawn stmts, compile as one sub-chunk

    // Token scanning to identify spans:
    flux spans = []  // [type, start_pos, end_pos] where type = "spawn" or "stmt"
    while pos < body_end {
        if peek_type() == "spawn" && pos + 1 < len(tokens) && tokens[pos + 1].text == "{" {
            let sp_start = pos
            advance()  // consume 'spawn'
            advance()  // consume '{'
            flux depth = 1
            while depth > 0 && peek() != nil {
                if peek_text() == "{" { depth = depth + 1 }
                if peek_text() == "}" { depth = depth - 1 }
                if depth > 0 { advance() }
            }
            advance()  // consume closing '}'
            spans.push(["spawn", sp_start, pos])
        } else {
            // Non-spawn statement: scan to end of statement
            let stmt_start = pos
            // Scan one statement/expression to find its end
            // Use brace-depth tracking for blocks
            flux stmt_depth = 0
            flux found_end = false
            while !found_end && pos < body_end {
                let st = peek_text()
                if st == "{" { stmt_depth = stmt_depth + 1 }
                if st == "}" {
                    if stmt_depth == 0 {
                        found_end = true
                    } else {
                        stmt_depth = stmt_depth - 1
                        advance()
                    }
                } else {
                    advance()
                    // If we're at depth 0 and the next token starts a new statement
                    // or is a spawn keyword, we've finished this statement
                    if stmt_depth == 0 && pos < body_end {
                        let nt = peek()
                        if nt != nil {
                            if nt.type == "spawn" && pos + 1 < len(tokens) && tokens[pos + 1].text == "{" {
                                found_end = true
                            }
                        }
                    }
                }
            }
            if pos > stmt_start {
                spans.push(["stmt", stmt_start, pos])
            }
        }
    }

    // Reset to body start for compilation
    pos = body_start

    // Count spawns and sync spans
    flux spawn_span_count = 0
    flux sync_span_count = 0
    for si in 0..len(spans) {
        if spans[si][0] == "spawn" {
            spawn_span_count = spawn_span_count + 1
        } else {
            sync_span_count = sync_span_count + 1
        }
    }

    // Compile sync body: all non-spawn statements as one sub-chunk
    let sync_idx = 255  // 0xFF = no sync body
    if sync_span_count > 0 {
        save_compiler()
        let saved_stack_sync = init_sub_compiler()

        // Compile each non-spawn span by jumping pos to it
        // Track whether the last item compiled was an expression
        flux last_was_expr = false
        for si in 0..len(spans) {
            if spans[si][0] == "stmt" {
                pos = spans[si][1]
                while pos < spans[si][2] {
                    if last_was_expr {
                        emit_byte(OP_POP, line)
                    }
                    last_was_expr = false
                    if is_statement_start() {
                        parse_statement()
                    } else {
                        parse_expression()
                        last_was_expr = true
                    }
                    emit_byte(OP_RESET_EPHEMERAL, line)
                }
            }
        }
        if !last_was_expr {
            emit_byte(OP_UNIT, line)
        }
        emit_byte(OP_RETURN, line)

        let sync_snap = snapshot_chunk()
        compiler_stack = saved_stack_sync
        restore_compiler()
        sync_idx = add_constant(make_closure_const(0, false, sync_snap))
    }

    // Compile each spawn body as a sub-chunk
    for si in 0..len(spans) {
        if spans[si][0] == "spawn" {
            save_compiler()
            let saved_stack_spawn = init_sub_compiler()

            pos = spans[si][1]
            advance()  // skip 'spawn'
            advance()  // skip '{'
            while peek_text() != "}" {
                if peek() == nil {
                    compiler_error("unexpected end of input in spawn body", line)
                }
                parse_statement_or_expression()
            }
            advance()  // skip '}'
            emit_byte(OP_UNIT, line)
            emit_byte(OP_RETURN, line)

            let spawn_snap = snapshot_chunk()
            compiler_stack = saved_stack_spawn
            restore_compiler()
            spawn_indices.push(add_constant(make_closure_const(0, false, spawn_snap)))
        }
    }

    // Restore position past the scope body
    pos = body_end
    expect(nil, "}")

    // Emit OP_SCOPE: spawn_count, sync_idx, [spawn_idx...]
    emit_byte(OP_SCOPE, line)
    emit_byte(len(spawn_indices), line)
    emit_byte(sync_idx, line)
    for si in 0..len(spawn_indices) {
        emit_byte(spawn_indices[si], line)
    }
}

fn parse_select() {
    let line = current_line()
    advance()  // consume 'select'
    expect(nil, "{")

    flux arm_count = 0
    flux arm_data = []  // array of [flags, chan_idx, body_idx, binding_idx]

    while peek_text() != "}" {
        if peek() == nil {
            compiler_error("unexpected end of input in select body", line)
        }

        // Check for 'default' arm
        if peek_type() == "identifier" && peek_text() == "default" {
            advance()  // consume 'default'
            expect(nil, "=>")
            expect(nil, "{")

            // Compile body as sub-chunk
            save_compiler()
            let ss_default = init_sub_compiler()
            while peek_text() != "}" {
                if peek() == nil {
                    compiler_error("unexpected end of input in select default body", line)
                }
                parse_statement_or_expression()
            }
            emit_byte(OP_UNIT, line)
            emit_byte(OP_RETURN, line)
            let body_snap = snapshot_chunk()
            compiler_stack = ss_default
            restore_compiler()
            let body_idx = add_constant(make_closure_const(0, false, body_snap))

            expect(nil, "}")
            // Optional comma
            if peek_text() == "," { advance() }

            arm_data.push([1, 255, body_idx, 255])  // flags=0x01 (default), chan=0xFF, binding=0xFF
            arm_count = arm_count + 1
        } else { if peek_type() == "identifier" && peek_text() == "timeout" {
            advance()  // consume 'timeout'
            expect(nil, "(")

            // Compile timeout expression as sub-chunk
            let to_idx = compile_sub_expr_chunk(line)

            expect(nil, ")")
            expect(nil, "=>")
            expect(nil, "{")

            // Compile body as sub-chunk
            save_compiler()
            let ss_timeout = init_sub_compiler()
            while peek_text() != "}" {
                if peek() == nil {
                    compiler_error("unexpected end of input in select timeout body", line)
                }
                parse_statement_or_expression()
            }
            emit_byte(OP_UNIT, line)
            emit_byte(OP_RETURN, line)
            let body_snap = snapshot_chunk()
            compiler_stack = ss_timeout
            restore_compiler()
            let body_idx = add_constant(make_closure_const(0, false, body_snap))

            expect(nil, "}")
            if peek_text() == "," { advance() }

            arm_data.push([2, to_idx, body_idx, 255])  // flags=0x02 (timeout)
            arm_count = arm_count + 1
        } else {
            // Normal arm: binding from channel_expr => { body }
            let binding = expect("identifier", nil).text
            expect("from", nil)

            // Compile channel expression as sub-chunk
            let chan_idx = compile_sub_expr_chunk(line)

            expect(nil, "=>")
            expect(nil, "{")

            // Compile body as sub-chunk
            save_compiler()
            let ss_arm = init_sub_compiler()
            while peek_text() != "}" {
                if peek() == nil {
                    compiler_error("unexpected end of input in select arm body", line)
                }
                parse_statement_or_expression()
            }
            emit_byte(OP_UNIT, line)
            emit_byte(OP_RETURN, line)
            let body_snap = snapshot_chunk()
            compiler_stack = ss_arm
            restore_compiler()
            let body_idx = add_constant(make_closure_const(0, false, body_snap))

            expect(nil, "}")
            if peek_text() == "," { advance() }

            // Binding name as string constant
            let binding_idx = string_constant(binding)
            arm_data.push([4, chan_idx, body_idx, binding_idx])  // flags=0x04 (has binding)
            arm_count = arm_count + 1
        } }
    }

    expect(nil, "}")

    // Emit OP_SELECT: arm_count, [flags, chan_idx, body_idx, binding_idx] * arm_count
    emit_byte(OP_SELECT, line)
    emit_byte(arm_count, line)
    for ai in 0..arm_count {
        let arm = arm_data[ai]
        emit_byte(arm[0], line)  // flags
        emit_byte(arm[1], line)  // chan_idx
        emit_byte(arm[2], line)  // body_idx
        emit_byte(arm[3], line)  // binding_idx
    }
}

// ============================================================================
// Section 9: Statement parsing
// ============================================================================

fn is_statement_start() {
    let t = peek()
    if t == nil { return false }
    let txt = t.text
    if txt == "flux" { return true }
    if txt == "fix" { return true }
    if txt == "let" { return true }
    if t.type == "fn" { return true }
    if txt == "return" { return true }
    if txt == "while" { return true }
    if txt == "loop" { return true }
    if txt == "for" { return true }
    if txt == "break" { return true }
    if txt == "continue" { return true }
    if txt == "struct" { return true }
    if txt == "enum" { return true }
    if txt == "defer" { return true }
    if txt == "try" { return true }
    if txt == "import" { return true }
    if txt == "impl" { return true }
    if txt == "trait" { return true }
    if t.type == "scope" { return true }
    // @fluid / @crystal annotations before fn/struct
    if t.type == "@" || txt == "@" { return true }
    if t.type == "identifier" {
        if txt == "select" && pos + 1 < len(tokens) && tokens[pos + 1].text == "{" {
            return true
        }
        if pos + 1 < len(tokens) {
            let next = tokens[pos + 1]
            if next.text == "=" { return true }
            if next.text == "+=" { return true }
            if next.text == "-=" { return true }
            if next.text == "*=" { return true }
            if next.text == "/=" { return true }
            if next.text == "%=" { return true }
            if next.text == "." {
                flux j = pos + 1
                while j < len(tokens) {
                    let nt = tokens[j]
                    if nt.text == "=" || nt.text == "+=" || nt.text == "-=" || nt.text == "*=" || nt.text == "/=" || nt.text == "%=" {
                        return true
                    }
                    if nt.text == "." || nt.type == "identifier" || nt.text == "[" {
                        j = j + 1
                    } else {
                        break
                    }
                }
            }
            if next.text == "[" { return true }
        }
    }
    return false
}

fn parse_statement() {
    let t = peek()
    let txt = t.text
    let line = current_line()

    if txt == "flux" || txt == "fix" || txt == "let" {
        parse_declaration()
        return
    }

    if t.type == "fn" {
        parse_fn_declaration()
        return
    }

    if txt == "return" {
        parse_return()
        return
    }

    if txt == "while" {
        parse_while()
        return
    }

    if txt == "loop" {
        parse_loop_stmt()
        return
    }

    if txt == "for" {
        parse_for()
        return
    }

    if txt == "break" {
        parse_break()
        return
    }

    if txt == "continue" {
        parse_continue()
        return
    }

    if txt == "struct" {
        parse_struct_declaration()
        return
    }

    if txt == "enum" {
        parse_enum_declaration()
        return
    }

    if txt == "defer" {
        parse_defer()
        return
    }

    if txt == "try" {
        parse_try_catch()
        return
    }

    if txt == "import" {
        parse_import()
        return
    }

    if txt == "impl" {
        parse_impl_block()
        return
    }

    if txt == "trait" {
        parse_trait_declaration()
        return
    }

    // @fluid / @crystal annotations: consume and apply to next declaration
    if t.type == "@" || txt == "@" {
        parse_annotation()
        return
    }

    if t.type == "scope" {
        parse_scope()
        emit_byte(OP_POP, line)
        return
    }

    if t.type == "identifier" {
        if txt == "select" && pos + 1 < len(tokens) && tokens[pos + 1].text == "{" {
            parse_select()
            emit_byte(OP_POP, line)
            return
        }
        parse_assignment()
        return
    }

    compiler_error("unexpected statement token '" + txt + "'", line)
}

fn parse_declaration() {
    let line = current_line()
    let kind = advance().text

    // Check for destructuring: let [a, b] = ... or let { x, y } = ...
    if peek_text() == "[" {
        parse_array_destructure(kind, line)
        return
    }
    if peek_text() == "{" {
        parse_struct_destructure(kind, line)
        return
    }

    let name = expect("identifier", nil).text
    expect(nil, "=")
    parse_expression()

    if kind == "fix" {
        emit_byte(OP_FREEZE, line)
    }
    if kind == "flux" {
        emit_byte(OP_MARK_FLUID, line)
    }

    if scope_depth > 0 {
        add_local(name)
    } else {
        let idx = string_constant(name)
        emit_wide_op(OP_DEFINE_GLOBAL, OP_DEFINE_GLOBAL_16, idx, line)
    }
}

fn parse_array_destructure(kind: any, line: any) {
    advance()  // consume '['
    flux names = []
    while peek_text() != "]" {
        names.push(expect("identifier", nil).text)
        if peek_text() == "," { advance() }
    }
    expect(nil, "]")
    expect(nil, "=")
    parse_expression()

    let name_count = len(names)
    if scope_depth > 0 {
        // Local scope: store source as hidden local
        add_local("")
        let src_slot = local_count - 1
        for i in 0..name_count {
            emit_bytes(OP_GET_LOCAL, src_slot, line)
            emit_constant(make_int_const(i), line)
            emit_byte(OP_INDEX, line)
            if kind == "fix" {
                emit_byte(OP_FREEZE, line)
            }
            if kind == "flux" {
                emit_byte(OP_MARK_FLUID, line)
            }
            add_local(names[i])
        }
    } else {
        // Global scope: use DUP
        for i in 0..name_count {
            emit_byte(OP_DUP, line)
            emit_constant(make_int_const(i), line)
            emit_byte(OP_INDEX, line)
            if kind == "fix" {
                emit_byte(OP_FREEZE, line)
            }
            if kind == "flux" {
                emit_byte(OP_MARK_FLUID, line)
            }
            let idx = string_constant(names[i])
            emit_wide_op(OP_DEFINE_GLOBAL, OP_DEFINE_GLOBAL_16, idx, line)
        }
        emit_byte(OP_POP, line)
    }
}

fn parse_struct_destructure(kind: any, line: any) {
    advance()  // consume '{'
    flux names = []
    while peek_text() != "}" {
        names.push(expect("identifier", nil).text)
        if peek_text() == "," { advance() }
    }
    expect(nil, "}")
    expect(nil, "=")
    parse_expression()

    let name_count = len(names)
    if scope_depth > 0 {
        add_local("")
        let src_slot = local_count - 1
        for i in 0..name_count {
            emit_bytes(OP_GET_LOCAL, src_slot, line)
            let fidx = string_constant(names[i])
            emit_bytes(OP_GET_FIELD, fidx, line)
            if kind == "fix" {
                emit_byte(OP_FREEZE, line)
            }
            if kind == "flux" {
                emit_byte(OP_MARK_FLUID, line)
            }
            add_local(names[i])
        }
    } else {
        for i in 0..name_count {
            emit_byte(OP_DUP, line)
            let fidx = string_constant(names[i])
            emit_bytes(OP_GET_FIELD, fidx, line)
            if kind == "fix" {
                emit_byte(OP_FREEZE, line)
            }
            if kind == "flux" {
                emit_byte(OP_MARK_FLUID, line)
            }
            let nidx = string_constant(names[i])
            emit_wide_op(OP_DEFINE_GLOBAL, OP_DEFINE_GLOBAL_16, nidx, line)
        }
        emit_byte(OP_POP, line)
    }
}

fn parse_fn_declaration() {
    let line = current_line()
    expect("fn", nil)
    let name = expect("identifier", nil).text
    if name == "main" { has_main_fn = true }
    expect(nil, "(")

    flux param_names_arr = []
    flux has_variadic = false
    if peek_text() != ")" {
        let p = expect("identifier", nil).text
        // Consume optional type annotation
        if peek_text() == ":" {
            advance()
            expect("identifier", nil)  // type name
        }
        param_names_arr.push(p)
        while peek_text() == "," {
            advance()
            if peek_text() == "..." {
                advance()
                let vp = expect("identifier", nil).text
                if peek_text() == ":" {
                    advance()
                    expect("identifier", nil)
                }
                param_names_arr.push(vp)
                has_variadic = true
                break
            }
            let p2 = expect("identifier", nil).text
            if peek_text() == ":" {
                advance()
                expect("identifier", nil)
            }
            param_names_arr.push(p2)
        }
    }
    expect(nil, ")")

    // Skip optional return type annotation
    if peek_text() == "->" {
        advance()
        expect("identifier", nil)
    }

    // Collect require/ensure contract token positions.
    // require/ensure are contextual identifiers appearing before '{'.
    // Strategy: save the position of each contract's condition expression start,
    // then scan forward (skipping balanced brackets) to find the body '{'.
    // Later, backtrack to compile each contract.
    flux contract_starts = []
    flux contract_is_ensure_arr = []
    flux contract_msg_arr = []
    let contracts_begin_pos = pos
    // Scan forward to find the body '{' — track balanced brackets
    flux scan_depth = 0
    while peek() != nil {
        let ct = peek_text()
        if ct == "(" || ct == "[" { scan_depth = scan_depth + 1 }
        if ct == ")" || ct == "]" { scan_depth = scan_depth - 1 }
        if ct == "|" && scan_depth == 0 {
            // Skip closure: |...| { ... }
            advance()
            while peek() != nil && peek_text() != "|" { advance() }
            if peek_text() == "|" { advance() }
            if peek_text() == "{" {
                advance()
                flux cd = 1
                while cd > 0 && peek() != nil {
                    if peek_text() == "{" { cd = cd + 1 }
                    if peek_text() == "}" { cd = cd - 1 }
                    if cd > 0 { advance() }
                }
                if peek_text() == "}" { advance() }
            }
        } else { if ct == "{" && scan_depth == 0 {
            break
        } else {
            advance()
        } }
    }
    let body_brace_pos = pos
    // Now backtrack and identify each contract clause
    pos = contracts_begin_pos
    while peek_type() == "identifier" && (peek_text() == "require" || peek_text() == "ensure") {
        let is_ens = peek_text() == "ensure"
        advance()  // consume "require"/"ensure"
        contract_is_ensure_arr.push(is_ens)
        contract_starts.push(pos)  // save position of condition expression
        // Skip to next require/ensure or body '{' by scanning with balanced brackets
        flux skip_depth = 0
        while pos < body_brace_pos && peek() != nil {
            let st = peek_text()
            if st == "(" || st == "[" { skip_depth = skip_depth + 1 }
            if st == ")" || st == "]" { skip_depth = skip_depth - 1 }
            if st == "|" && skip_depth == 0 {
                // Closure — skip |...| { ... }
                advance()
                while peek() != nil && peek_text() != "|" { advance() }
                if peek_text() == "|" { advance() }
                if peek_text() == "{" {
                    advance()
                    flux cd2 = 1
                    while cd2 > 0 && peek() != nil {
                        if peek_text() == "{" { cd2 = cd2 + 1 }
                        if peek_text() == "}" { cd2 = cd2 - 1 }
                        if cd2 > 0 { advance() }
                    }
                    if peek_text() == "}" { advance() }
                }
                break
            }
            if skip_depth == 0 {
                if st == "require" || st == "ensure" {
                    break
                }
                if st == "," {
                    advance()
                    if peek_type() == "string" {
                        let msg = advance().text
                        contract_msg_arr.push(msg)
                    } else {
                        contract_msg_arr.push("condition not met")
                    }
                    break
                }
            }
            advance()
        }
        if len(contract_msg_arr) < len(contract_starts) {
            contract_msg_arr.push("condition not met")
        }
    }
    // pos should now be at body_brace_pos
    pos = body_brace_pos
    let contract_count = len(contract_starts)

    let param_count = len(param_names_arr)

    save_compiler()

    code = []
    c_lines = []
    constants = []
    local_names = []
    local_name_arr = []
    local_depth_arr = []
    local_captured_arr = []
    local_count = 0
    scope_depth = 0
    upvalue_index_arr = []
    upvalue_islocal_arr = []
    upvalue_count = 0
    func_type = "function"
    break_jumps = []
    break_count = 0
    loop_start_pos = 0
    loop_depth = 0
    string_intern_map = Map::new()
    ensure_slots = []
    ensure_messages = []
    ensure_count = 0
    current_func_name = name

    // Reserve slot 0 for the function itself (VM convention)
    add_local("")
    begin_scope()

    for i in 0..param_count {
        add_local(param_names_arr[i])
    }

    // Now compile contracts by backtracking to their saved positions
    let body_start_pos = pos  // save where the '{' is
    flux ci = 0
    while ci < contract_count {
        pos = contract_starts[ci]
        if contract_is_ensure_arr[ci] {
            // Ensure: compile the closure expression and store in a hidden local
            parse_expression()
            add_local("")  // hidden local for ensure closure
            let slot = local_count - 1
            ensure_slots.push(slot)
            ensure_messages.push(contract_msg_arr[ci])
            ensure_count = ensure_count + 1
        } else {
            // Require: compile condition, check, throw if false
            parse_expression()
            let ok_jump = emit_jump(OP_JUMP_IF_TRUE, line)
            emit_byte(OP_POP, line)
            let full_msg = "require failed in '" + name + "': " + contract_msg_arr[ci]
            emit_constant(make_string_const(full_msg), line)
            emit_byte(OP_THROW, line)
            patch_jump(ok_jump)
            emit_byte(OP_POP, line)  // pop true
        }
        ci = ci + 1
    }
    pos = body_start_pos  // restore to where '{' is

    expect(nil, "{")
    while peek_text() != "}" {
        if peek() == nil {
            compiler_error("unexpected end of input in function body", line)
        }
        parse_statement_or_expression()
    }
    expect(nil, "}")

    emit_byte(OP_UNIT, line)
    emit_ensure_checks(line)
    emit_byte(OP_DEFER_RUN, line)
    emit_byte(0, line)  // scope_depth 0 = run all defers
    emit_byte(OP_RETURN, line)

    let fn_snap = snapshot_chunk()
    let fn_uv_idx = upvalue_index_arr
    let fn_uv_loc = upvalue_islocal_arr
    let fn_uv_count = upvalue_count

    restore_compiler()

    let fn_const = make_closure_const(param_count, has_variadic, fn_snap)
    let fn_idx = add_constant(fn_const)

    emit_wide_op(OP_CLOSURE, OP_CLOSURE_16, fn_idx, line)
    emit_byte(fn_uv_count, line)
    flux i = 0
    while i < fn_uv_count {
        if fn_uv_loc[i] {
            emit_byte(1, line)
        } else {
            emit_byte(0, line)
        }
        emit_byte(fn_uv_idx[i], line)
        i = i + 1
    }

    if scope_depth > 0 {
        add_local(name)
    } else {
        let idx = string_constant(name)
        emit_wide_op(OP_DEFINE_GLOBAL, OP_DEFINE_GLOBAL_16, idx, line)
    }
}

fn parse_statement_or_expression() {
    let line = current_line()
    if is_statement_start() {
        parse_statement()
    } else {
        parse_expression()
        emit_byte(OP_POP, line)
    }
    emit_byte(OP_RESET_EPHEMERAL, line)
}

fn parse_return() {
    let line = current_line()
    advance()
    if peek_text() == "}" || peek() == nil {
        emit_byte(OP_UNIT, line)
    } else {
        parse_expression()
    }
    emit_ensure_checks(line)
    emit_byte(OP_DEFER_RUN, line)
    emit_byte(0, line)  // scope_depth 0 = run all defers
    emit_byte(OP_RETURN, line)
}

fn parse_while() {
    let line = current_line()
    advance()

    let outer_break_jumps = break_jumps
    let outer_break_count = break_count
    let outer_loop_start = loop_start_pos
    let outer_loop_depth = loop_depth
    let outer_break_lc = loop_break_local_count
    let outer_continue_lc = loop_continue_local_count

    let loop_begin = len(code)
    loop_start_pos = loop_begin
    loop_depth = scope_depth
    break_jumps = []
    break_count = 0
    loop_break_local_count = local_count
    loop_continue_local_count = local_count

    parse_expression()
    let exit_jump = emit_jump(OP_JUMP_IF_FALSE, line)
    emit_byte(OP_POP, line)

    expect(nil, "{")
    begin_scope()
    while peek_text() != "}" {
        if peek() == nil {
            compiler_error("unexpected end of input in while body", line)
        }
        parse_statement_or_expression()
    }
    expect(nil, "}")
    end_scope(line)

    emit_loop(loop_begin, line)
    patch_jump(exit_jump)
    emit_byte(OP_POP, line)

    flux bi = 0
    while bi < break_count {
        patch_jump(break_jumps[bi])
        bi = bi + 1
    }

    break_jumps = outer_break_jumps
    break_count = outer_break_count
    loop_start_pos = outer_loop_start
    loop_depth = outer_loop_depth
    loop_break_local_count = outer_break_lc
    loop_continue_local_count = outer_continue_lc
}

fn parse_loop_stmt() {
    let line = current_line()
    advance()

    let outer_break_jumps = break_jumps
    let outer_break_count = break_count
    let outer_loop_start = loop_start_pos
    let outer_loop_depth = loop_depth
    let outer_break_lc = loop_break_local_count
    let outer_continue_lc = loop_continue_local_count

    let loop_begin = len(code)
    loop_start_pos = loop_begin
    loop_depth = scope_depth
    break_jumps = []
    break_count = 0
    loop_break_local_count = local_count
    loop_continue_local_count = local_count

    expect(nil, "{")
    begin_scope()
    while peek_text() != "}" {
        if peek() == nil {
            compiler_error("unexpected end of input in loop body", line)
        }
        parse_statement_or_expression()
    }
    expect(nil, "}")
    end_scope(line)

    emit_loop(loop_begin, line)

    flux bi = 0
    while bi < break_count {
        patch_jump(break_jumps[bi])
        bi = bi + 1
    }

    break_jumps = outer_break_jumps
    break_count = outer_break_count
    loop_start_pos = outer_loop_start
    loop_depth = outer_loop_depth
    loop_break_local_count = outer_break_lc
    loop_continue_local_count = outer_continue_lc
}

fn parse_for() {
    let line = current_line()
    advance()
    let var_name = expect("identifier", nil).text
    expect("in", nil)

    parse_expression()
    emit_byte(OP_ITER_INIT, line)

    let outer_break_jumps = break_jumps
    let outer_break_count = break_count
    let outer_loop_start = loop_start_pos
    let outer_loop_depth = loop_depth
    let outer_break_lc = loop_break_local_count
    let outer_continue_lc = loop_continue_local_count

    begin_scope()
    // Iterator state uses TWO stack slots: collection + index
    add_local("")   // collection
    add_local("")   // index

    loop_continue_local_count = local_count

    let loop_begin = len(code)
    loop_start_pos = loop_begin
    loop_depth = scope_depth
    break_jumps = []
    break_count = 0
    loop_break_local_count = local_count

    let exit_jump = emit_jump(OP_ITER_NEXT, line)
    add_local(var_name)

    expect(nil, "{")
    begin_scope()
    while peek_text() != "}" {
        if peek() == nil {
            compiler_error("unexpected end of input in for body", line)
        }
        parse_statement_or_expression()
    }
    expect(nil, "}")
    end_scope(line)

    // Pop loop variable
    emit_byte(OP_POP, line)
    local_count = local_count - 1

    emit_loop(loop_begin, line)
    patch_jump(exit_jump)

    // Pop iterator state (2 values)
    emit_byte(OP_POP, line)
    emit_byte(OP_POP, line)
    local_count = local_count - 2

    flux bi = 0
    while bi < break_count {
        patch_jump(break_jumps[bi])
        bi = bi + 1
    }

    end_scope(line)

    break_jumps = outer_break_jumps
    break_count = outer_break_count
    loop_start_pos = outer_loop_start
    loop_depth = outer_loop_depth
    loop_break_local_count = outer_break_lc
    loop_continue_local_count = outer_continue_lc
}

fn parse_break() {
    let line = current_line()
    advance()
    flux i = local_count - 1
    while i >= loop_break_local_count {
        if local_captured_arr[i] {
            emit_byte(OP_CLOSE_UPVALUE, line)
        } else {
            emit_byte(OP_POP, line)
        }
        i = i - 1
    }
    let jump = emit_jump(OP_JUMP, line)
    if break_count >= len(break_jumps) {
        break_jumps.push(jump)
    } else {
        break_jumps[break_count] = jump
    }
    break_count = break_count + 1
}

fn parse_continue() {
    let line = current_line()
    advance()
    flux i = local_count - 1
    while i >= loop_continue_local_count {
        if local_captured_arr[i] {
            emit_byte(OP_CLOSE_UPVALUE, line)
        } else {
            emit_byte(OP_POP, line)
        }
        i = i - 1
    }
    emit_loop(loop_start_pos, line)
}

fn parse_assignment() {
    let line = current_line()
    let name = advance().text

    if peek_text() == "." || peek_text() == "[" {
        parse_compound_assignment_target(name, line)
        return
    }

    let op = advance().text

    if op == "=" {
        parse_expression()
        emit_variable_set_pop(name, line)
    } else {
        emit_variable_get(name, line)
        parse_expression()
        match op {
            "+=" => emit_byte(OP_ADD, line),
            "-=" => emit_byte(OP_SUB, line),
            "*=" => emit_byte(OP_MUL, line),
            "/=" => emit_byte(OP_DIV, line),
            _ => emit_byte(OP_MOD, line)
        }
        emit_variable_set_pop(name, line)
    }
}

fn parse_compound_assignment_target(name: any, line: any) {
    // Handle single-level: obj.field = or obj[idx] =
    if peek_text() == "." {
        advance()
        let field = expect("identifier", nil).text
        let op = advance().text
        if op == "=" {
            // VM expects stack: [value, object] then SET_FIELD pops obj, pops val
            parse_expression()
            emit_variable_get(name, line)
            let fidx = string_constant(field)
            emit_bytes(OP_SET_FIELD, fidx, line)
        } else {
            // Compound assignment: obj.field += expr
            // First, get the current field value
            emit_variable_get(name, line)
            let fidx = string_constant(field)
            emit_bytes(OP_GET_FIELD, fidx, line)
            // Compute new value
            parse_expression()
            match op {
                "+=" => emit_byte(OP_ADD, line),
                "-=" => emit_byte(OP_SUB, line),
                "*=" => emit_byte(OP_MUL, line),
                "/=" => emit_byte(OP_DIV, line),
                _ => emit_byte(OP_MOD, line)
            }
            // Stack: [new_value]. Now push object for SET_FIELD.
            emit_variable_get(name, line)
            let fidx2 = string_constant(field)
            emit_bytes(OP_SET_FIELD, fidx2, line)
        }
        // SET_FIELD leaves modified object on stack — write it back to variable
        emit_variable_set_pop(name, line)
    } else { if peek_text() == "[" {
        advance()
        let slot = resolve_local(name)
        if slot >= 0 {
            // Local array: use OP_SET_INDEX_LOCAL for in-place mutation
            // C compiler order: push value, push index, SET_INDEX_LOCAL slot
            // But source is: name[index] = value — so parse index first, then value, then swap
            parse_expression()
            expect(nil, "]")
            let op = advance().text
            if op == "=" {
                parse_expression()
                // Stack: [index, value]. Need [value, index].
                emit_byte(OP_SWAP, line)
                emit_bytes(OP_SET_INDEX_LOCAL, slot, line)
            } else {
                // Compound assignment: arr[i] += expr
                // Stack so far: [index]. Get current value first.
                emit_byte(OP_DUP, line)          // [index, index]
                emit_bytes(OP_GET_LOCAL, slot, line) // [index, index, arr]
                emit_byte(OP_SWAP, line)          // [index, arr, index]
                emit_byte(OP_INDEX, line)         // [index, current_val]
                parse_expression()                // [index, current_val, rhs]
                match op {
                    "+=" => emit_byte(OP_ADD, line),
                    "-=" => emit_byte(OP_SUB, line),
                    "*=" => emit_byte(OP_MUL, line),
                    "/=" => emit_byte(OP_DIV, line),
                    _ => emit_byte(OP_MOD, line)
                }
                // Stack: [index, new_val]. Need [new_val, index].
                emit_byte(OP_SWAP, line)
                emit_bytes(OP_SET_INDEX_LOCAL, slot, line)
            }
        } else {
            // Non-local: use OP_SET_INDEX
            // VM expects stack: [value, object, index] (value deepest)
            // Parse index, then ], =, then value. Then push object and index.
            parse_expression()
            expect(nil, "]")
            let op = advance().text
            if op == "=" {
                parse_expression()
                // Stack: [index, value]. Need [value, object, index].
                emit_byte(OP_SWAP, line)
                // Stack: [value, index]. Now push object and reorder.
                emit_variable_get(name, line)
                emit_byte(OP_SWAP, line)
                // Stack: [value, object, index]. Correct!
                emit_byte(OP_SET_INDEX, line)
            } else {
                // Compound assignment: map[key] += expr (non-local)
                // Stack so far: [index]. Get current value first.
                emit_byte(OP_DUP, line)              // [index, index]
                emit_variable_get(name, line)         // [index, index, obj]
                emit_byte(OP_SWAP, line)              // [index, obj, index]
                emit_byte(OP_INDEX, line)             // [index, current_val]
                parse_expression()                    // [index, current_val, rhs]
                match op {
                    "+=" => emit_byte(OP_ADD, line),
                    "-=" => emit_byte(OP_SUB, line),
                    "*=" => emit_byte(OP_MUL, line),
                    "/=" => emit_byte(OP_DIV, line),
                    _ => emit_byte(OP_MOD, line)
                }
                // Stack: [index, new_val]. Need [new_val, obj, index].
                emit_byte(OP_SWAP, line)              // [new_val, index]
                emit_variable_get(name, line)         // [new_val, index, obj]
                emit_byte(OP_SWAP, line)              // [new_val, obj, index]
                emit_byte(OP_SET_INDEX, line)
            }
            emit_byte(OP_POP, line)
        }
    } }
}

fn parse_struct_declaration() {
    let line = current_line()
    advance()
    let name = expect("identifier", nil).text
    expect(nil, "{")

    flux field_names_arr = []
    flux field_phases_arr = []  // per-field phase: 0=fluid, 1=crystal, 2=unspecified

    while peek_text() != "}" {
        if peek() == nil {
            compiler_error("unexpected end of input in struct declaration", line)
        }
        if peek_type() == "fn" {
            // Skip methods in struct body (handled by impl blocks)
            advance()
            expect("identifier", nil)
            expect(nil, "(")
            while peek_text() != ")" {
                advance()
            }
            expect(nil, ")")
            if peek_text() == "->" {
                advance()
                advance()
            }
            expect(nil, "{")
            flux depth = 1
            while depth > 0 {
                let mt = advance()
                if mt.text == "{" { depth = depth + 1 }
                if mt.text == "}" { depth = depth - 1 }
            }
        } else {
            let fname = expect("identifier", nil).text
            field_names_arr.push(fname)
            flux field_phase = 2  // PHASE_UNSPECIFIED
            if peek_text() == ":" {
                advance()
                // Check for phase prefix: ~ (fluid), * (crystal), flux, fix
                // Also handle composite constraints: (flux|fix), (~|*), etc.
                if peek_text() == "~" || peek_type() == "~" {
                    field_phase = 0  // PHASE_FLUID
                    advance()
                } else { if peek_text() == "*" || peek_type() == "*" {
                    field_phase = 1  // PHASE_CRYSTAL
                    advance()
                } else { if peek_type() == "flux" || peek_text() == "flux" {
                    field_phase = 0  // PHASE_FLUID
                    advance()
                } else { if peek_type() == "fix" || peek_text() == "fix" {
                    field_phase = 1  // PHASE_CRYSTAL
                    advance()
                } else { if peek_text() == "(" {
                    // Composite constraint: skip it (e.g., (flux|fix))
                    advance()
                    while peek_text() != ")" && peek() != nil {
                        advance()
                    }
                    if peek_text() == ")" { advance() }
                } } } } }
                // Parse type name (may be [ArrayType] or plain identifier)
                if peek_text() == "[" {
                    advance()
                    // Skip inner type
                    if peek_text() != "]" { advance() }
                    expect(nil, "]")
                } else { if peek_type() == "identifier" || peek_type() == "fn" {
                    advance()
                } }
            }
            field_phases_arr.push(field_phase)
            if peek_text() == "," {
                advance()
            }
        }
    }
    expect(nil, "}")

    // Emit struct metadata: array of field name strings as __struct_<Name>
    let field_count = len(field_names_arr)
    for i in 0..field_count {
        emit_constant(make_string_const(field_names_arr[i]), line)
    }
    emit_bytes(OP_BUILD_ARRAY, field_count, line)
    let meta_name = "__struct_" + name
    let idx = string_constant(meta_name)
    emit_wide_op(OP_DEFINE_GLOBAL, OP_DEFINE_GLOBAL_16, idx, line)

    // Alloy: emit per-field phase metadata if any field has a phase annotation
    flux has_phase = false
    for i in 0..field_count {
        if field_phases_arr[i] != 2 {
            has_phase = true
            break
        }
    }
    if has_phase {
        for i in 0..field_count {
            emit_constant(make_int_const(field_phases_arr[i]), line)
        }
        emit_bytes(OP_BUILD_ARRAY, field_count, line)
        let phase_meta = "__struct_phases_" + name
        let pidx = string_constant(phase_meta)
        emit_wide_op(OP_DEFINE_GLOBAL, OP_DEFINE_GLOBAL_16, pidx, line)
    }
}

fn parse_enum_declaration() {
    let line = current_line()
    advance()
    let name = expect("identifier", nil).text
    expect(nil, "{")

    while peek_text() != "}" {
        if peek() == nil {
            compiler_error("unexpected end of input in enum declaration", line)
        }
        expect("identifier", nil)
        if peek_text() == "(" {
            advance()
            while peek_text() != ")" {
                advance()
                if peek_text() == "," { advance() }
            }
            expect(nil, ")")
        }
        if peek_text() == "," {
            advance()
        }
    }
    expect(nil, "}")

    // Register known enum and emit metadata
    known_enums.push(name)
    let meta_name = "__enum_" + name
    emit_byte(OP_TRUE, line)
    let idx = string_constant(meta_name)
    emit_wide_op(OP_DEFINE_GLOBAL, OP_DEFINE_GLOBAL_16, idx, line)
}

fn parse_defer() {
    let line = current_line()
    advance()

    // OP_DEFER_PUSH format: opcode(1) + scope_depth(1) + offset(2)
    emit_byte(OP_DEFER_PUSH, line)
    emit_byte(scope_depth, line)
    emit_byte(255, line)
    emit_byte(255, line)
    let jump = len(code) - 2

    expect(nil, "{")
    begin_scope()
    while peek_text() != "}" {
        if peek() == nil {
            compiler_error("unexpected end of input in defer body", line)
        }
        parse_statement_or_expression()
    }
    expect(nil, "}")
    end_scope(line)
    emit_byte(OP_RETURN, line)
    patch_jump(jump)
}

fn parse_try_catch() {
    let line = current_line()
    advance()

    let handler_jump = emit_jump(OP_PUSH_EXCEPTION_HANDLER, line)

    expect(nil, "{")
    begin_scope()
    while peek_text() != "}" {
        if peek() == nil {
            compiler_error("unexpected end of input in try body", line)
        }
        parse_statement_or_expression()
    }
    expect(nil, "}")
    end_scope(line)

    emit_byte(OP_POP_EXCEPTION_HANDLER, line)
    let skip_catch = emit_jump(OP_JUMP, line)

    patch_jump(handler_jump)
    expect(nil, "catch")
    let err_name = expect("identifier", nil).text

    expect(nil, "{")
    begin_scope()
    add_local(err_name)

    while peek_text() != "}" {
        if peek() == nil {
            compiler_error("unexpected end of input in catch body", line)
        }
        parse_statement_or_expression()
    }
    expect(nil, "}")
    end_scope(line)

    patch_jump(skip_catch)
}

fn parse_import() {
    let line = current_line()
    advance()
    let path = expect("string", nil).text
    let idx = string_constant(path)
    emit_bytes(OP_IMPORT, idx, line)
}

fn parse_annotation() {
    let line = current_line()
    advance()  // consume '@'
    let ann_name = expect("identifier", nil).text
    // @fluid and @crystal are the only supported annotations
    // They apply to the next fn or struct declaration.
    // For the self-hosted compiler, we consume the annotation and then
    // parse the following declaration normally. The annotation itself
    // is a static analysis hint (phase_annotation) that doesn't affect
    // bytecode generation directly.
    if ann_name != "fluid" && ann_name != "crystal" {
        compiler_error("unknown annotation '@" + ann_name + "' (expected @fluid or @crystal)", line)
    }
    // Parse the next declaration (fn, struct, etc.)
    let next_tok = peek()
    if next_tok == nil {
        compiler_error("expected declaration after @" + ann_name, line)
    }
    if next_tok.type == "fn" {
        parse_fn_declaration()
    } else { if next_tok.text == "struct" {
        parse_struct_declaration()
    } else {
        compiler_error("@" + ann_name + " annotation must precede fn or struct", line)
    } }
}

fn parse_trait_declaration() {
    let line = current_line()
    advance()  // consume 'trait'
    let trait_name = expect("identifier", nil).text
    expect(nil, "{")

    // Parse method signatures and collect method names
    flux method_names = []
    while peek_text() != "}" {
        if peek() == nil {
            compiler_error("unexpected end of input in trait declaration", line)
        }
        // Each entry should be: fn name(params...) [-> RetType]
        if peek_text() == "fn" {
            advance()  // consume 'fn'
            let mname = expect("identifier", nil).text
            method_names.push(mname)
            // Skip the rest of the signature (params, return type)
            // Use brace/paren depth tracking
            flux sig_depth = 0
            while peek() != nil {
                let st = peek_text()
                if st == "(" || st == "{" { sig_depth = sig_depth + 1 }
                if st == ")" || st == "}" { sig_depth = sig_depth - 1 }
                if sig_depth < 0 { break }
                advance()
                if sig_depth == 0 && (st == ")" || st == "}") { break }
            }
        } else {
            // Skip unexpected tokens
            advance()
        }
    }
    expect(nil, "}")

    // Emit trait metadata: __trait_<Name> = array of required method name strings
    let method_count = len(method_names)
    for i in 0..method_count {
        emit_constant(make_string_const(method_names[i]), line)
    }
    emit_bytes(OP_BUILD_ARRAY, method_count, line)
    let meta_name = "__trait_" + trait_name
    let idx = string_constant(meta_name)
    emit_wide_op(OP_DEFINE_GLOBAL, OP_DEFINE_GLOBAL_16, idx, line)
}

fn parse_impl_block() {
    let line = current_line()
    advance()  // consume 'impl'
    let trait_name = expect("identifier", nil).text
    expect(nil, "for")
    let type_name = expect("identifier", nil).text
    expect(nil, "{")

    while peek_text() != "}" {
        if peek() == nil {
            compiler_error("unexpected end of input in impl block", line)
        }
        expect("fn", nil)
        let method_name = expect("identifier", nil).text
        let full_name = type_name + "::" + method_name
        if method_name == "main" { has_main_fn = true }
        expect(nil, "(")

        flux param_names_arr = []
        flux has_variadic = false
        if peek_text() != ")" {
            let p = expect("identifier", nil).text
            if peek_text() == ":" {
                advance()
                expect("identifier", nil)
            }
            param_names_arr.push(p)
            while peek_text() == "," {
                advance()
                if peek_text() == "..." {
                    advance()
                    let vp = expect("identifier", nil).text
                    if peek_text() == ":" {
                        advance()
                        expect("identifier", nil)
                    }
                    param_names_arr.push(vp)
                    has_variadic = true
                    break
                }
                let p2 = expect("identifier", nil).text
                if peek_text() == ":" {
                    advance()
                    expect("identifier", nil)
                }
                param_names_arr.push(p2)
            }
        }
        expect(nil, ")")

        if peek_text() == "->" {
            advance()
            expect("identifier", nil)
        }

        // Parse require/ensure contracts for impl methods (same approach as fn)
        flux m_contract_starts = []
        flux m_contract_is_ensure_arr = []
        flux m_contract_msg_arr = []
        let m_contracts_begin_pos = pos
        flux m_scan_depth = 0
        while peek() != nil {
            let mct = peek_text()
            if mct == "(" || mct == "[" { m_scan_depth = m_scan_depth + 1 }
            if mct == ")" || mct == "]" { m_scan_depth = m_scan_depth - 1 }
            if mct == "|" && m_scan_depth == 0 {
                advance()
                while peek() != nil && peek_text() != "|" { advance() }
                if peek_text() == "|" { advance() }
                if peek_text() == "{" {
                    advance()
                    flux mcd = 1
                    while mcd > 0 && peek() != nil {
                        if peek_text() == "{" { mcd = mcd + 1 }
                        if peek_text() == "}" { mcd = mcd - 1 }
                        if mcd > 0 { advance() }
                    }
                    if peek_text() == "}" { advance() }
                }
            } else { if mct == "{" && m_scan_depth == 0 {
                break
            } else {
                advance()
            } }
        }
        let m_body_brace_pos = pos
        pos = m_contracts_begin_pos
        while peek_type() == "identifier" && (peek_text() == "require" || peek_text() == "ensure") {
            let m_is_ens = peek_text() == "ensure"
            advance()
            m_contract_is_ensure_arr.push(m_is_ens)
            m_contract_starts.push(pos)
            flux m_skip_depth = 0
            while pos < m_body_brace_pos && peek() != nil {
                let mst = peek_text()
                if mst == "(" || mst == "[" { m_skip_depth = m_skip_depth + 1 }
                if mst == ")" || mst == "]" { m_skip_depth = m_skip_depth - 1 }
                if mst == "|" && m_skip_depth == 0 {
                    advance()
                    while peek() != nil && peek_text() != "|" { advance() }
                    if peek_text() == "|" { advance() }
                    if peek_text() == "{" {
                        advance()
                        flux mcd2 = 1
                        while mcd2 > 0 && peek() != nil {
                            if peek_text() == "{" { mcd2 = mcd2 + 1 }
                            if peek_text() == "}" { mcd2 = mcd2 - 1 }
                            if mcd2 > 0 { advance() }
                        }
                        if peek_text() == "}" { advance() }
                    }
                    break
                }
                if m_skip_depth == 0 {
                    if mst == "require" || mst == "ensure" { break }
                    if mst == "," {
                        advance()
                        if peek_type() == "string" {
                            let mmsg = advance().text
                            m_contract_msg_arr.push(mmsg)
                        } else {
                            m_contract_msg_arr.push("condition not met")
                        }
                        break
                    }
                }
                advance()
            }
            if len(m_contract_msg_arr) < len(m_contract_starts) {
                m_contract_msg_arr.push("condition not met")
            }
        }
        pos = m_body_brace_pos
        let m_contract_count = len(m_contract_starts)

        let param_count = len(param_names_arr)

        // If first param is "self", it occupies slot 0 (the reserved slot)
        // and is excluded from arity
        flux first_param = 0
        if param_count > 0 && param_names_arr[0] == "self" {
            first_param = 1
        }
        let arity = param_count - first_param

        save_compiler()

        code = []
        c_lines = []
        constants = []
        local_names = []
        local_name_arr = []
        local_depth_arr = []
        local_captured_arr = []
        local_count = 0
        scope_depth = 0
        upvalue_index_arr = []
        upvalue_islocal_arr = []
        upvalue_count = 0
        func_type = "function"
        break_jumps = []
        break_count = 0
        loop_start_pos = 0
        loop_depth = 0
        string_intern_map = Map::new()
        ensure_slots = []
        ensure_messages = []
        ensure_count = 0
        current_func_name = full_name

        if first_param == 1 {
            // self occupies slot 0
            add_local("self")
        } else {
            add_local("")
        }
        begin_scope()

        for i in first_param..param_count {
            add_local(param_names_arr[i])
        }

        // Compile contracts by backtracking
        let m_body_start_pos = pos
        flux mci = 0
        while mci < m_contract_count {
            pos = m_contract_starts[mci]
            if m_contract_is_ensure_arr[mci] {
                parse_expression()
                add_local("")
                let m_slot = local_count - 1
                ensure_slots.push(m_slot)
                ensure_messages.push(m_contract_msg_arr[mci])
                ensure_count = ensure_count + 1
            } else {
                parse_expression()
                let m_ok_jump = emit_jump(OP_JUMP_IF_TRUE, line)
                emit_byte(OP_POP, line)
                let m_full_msg = "require failed in '" + full_name + "': " + m_contract_msg_arr[mci]
                emit_constant(make_string_const(m_full_msg), line)
                emit_byte(OP_THROW, line)
                patch_jump(m_ok_jump)
                emit_byte(OP_POP, line)
            }
            mci = mci + 1
        }
        pos = m_body_start_pos

        expect(nil, "{")
        while peek_text() != "}" {
            if peek() == nil {
                compiler_error("unexpected end of input in method body", line)
            }
            parse_statement_or_expression()
        }
        expect(nil, "}")

        emit_byte(OP_UNIT, line)
        emit_ensure_checks(line)
        emit_byte(OP_DEFER_RUN, line)
        emit_byte(0, line)
        emit_byte(OP_RETURN, line)

        let fn_snap = snapshot_chunk()
        let fn_uv_idx = upvalue_index_arr
        let fn_uv_loc = upvalue_islocal_arr
        let fn_uv_count = upvalue_count

        restore_compiler()

        let fn_const = make_closure_const(arity, has_variadic, fn_snap)
        let fn_idx = add_constant(fn_const)

        emit_wide_op(OP_CLOSURE, OP_CLOSURE_16, fn_idx, line)
        emit_byte(fn_uv_count, line)
        flux ui = 0
        while ui < fn_uv_count {
            if fn_uv_loc[ui] {
                emit_byte(1, line)
            } else {
                emit_byte(0, line)
            }
            emit_byte(fn_uv_idx[ui], line)
            ui = ui + 1
        }

        if scope_depth > 0 {
            add_local(full_name)
        } else {
            let name_idx = string_constant(full_name)
            emit_wide_op(OP_DEFINE_GLOBAL, OP_DEFINE_GLOBAL_16, name_idx, line)
        }
    }
    expect(nil, "}")

    // Emit impl metadata: __impl_<TypeName>_<TraitName> = true
    // This registers that TypeName implements TraitName
    emit_byte(OP_TRUE, line)
    let impl_meta = "__impl_" + type_name + "_" + trait_name
    let impl_idx = string_constant(impl_meta)
    emit_wide_op(OP_DEFINE_GLOBAL, OP_DEFINE_GLOBAL_16, impl_idx, line)
}

// ============================================================================
// Section 10: Top-level program compilation
// ============================================================================

fn compile_program() {
    let total_tokens = len(tokens)
    while pos < total_tokens {
        parse_statement_or_expression()
    }
    let line = current_line()
    // Auto-call main() if defined (matches C compiler behavior)
    if has_main_fn {
        let idx = string_constant("main")
        emit_wide_op(OP_GET_GLOBAL, OP_GET_GLOBAL_16, idx, line)
        emit_bytes(OP_CALL, 0, line)
        emit_byte(OP_POP, line)
    }
    emit_byte(OP_UNIT, line)
    emit_byte(OP_RETURN, line)
}

// ============================================================================
// Section 11: .latc serializer
// ============================================================================

// Global serialization buffer (Buffer is pass-by-value, so we must use global)
flux ser_buf = nil

fn write_u8(val: any) {
    ser_buf.push(val & 255)
}

fn write_u16_le(val: any) {
    ser_buf.push(val & 255)
    ser_buf.push((val >> 8) & 255)
}

fn write_u32_le(val: any) {
    ser_buf.push(val & 255)
    ser_buf.push((val >> 8) & 255)
    ser_buf.push((val >> 16) & 255)
    ser_buf.push((val >> 24) & 255)
}

fn write_i64_le(val: any) {
    flux v = val
    if v < 0 {
        flux remaining = v
        for i in 0..8 {
            let b = remaining & 255
            if b < 0 { ser_buf.push(b + 256) } else { ser_buf.push(b) }
            remaining = remaining >> 8
        }
        return
    }
    for i in 0..8 {
        ser_buf.push(v & 255)
        v = v >> 8
    }
}

fn write_f64_le(val: any) {
    let bits = float_to_bits(val)
    write_i64_le(bits)
}

fn write_string(str_val: any) {
    let slen = len(str_val)
    write_u32_le(slen)
    for i in 0..slen {
        ser_buf.push(ord(str_val[i]))
    }
}

fn serialize_constant(c: any) {
    let tag = c[0]
    if tag == TAG_INT {
        write_u8(TAG_INT)
        write_i64_le(c[1])
    } else { if tag == TAG_FLOAT {
        write_u8(TAG_FLOAT)
        write_f64_le(c[1])
    } else { if tag == TAG_BOOL {
        write_u8(TAG_BOOL)
        if c[1] { write_u8(1) } else { write_u8(0) }
    } else { if tag == TAG_STR {
        write_u8(TAG_STR)
        write_string(c[1])
    } else { if tag == TAG_NIL {
        write_u8(TAG_NIL)
    } else { if tag == TAG_UNIT {
        write_u8(TAG_UNIT)
    } else { if tag == TAG_CLOSURE {
        write_u8(TAG_CLOSURE)
        write_u32_le(c[1])   // param_count
        if c[2] { write_u8(1) } else { write_u8(0) }  // has_variadic
        serialize_chunk(c[3]) // chunk snapshot
    } } } } } } }
}

fn serialize_chunk(ch: any) {
    // ch = [code_arr, lines_arr, constants_arr, local_names_arr]
    let ch_code = ch[0]
    let ch_lines = ch[1]
    let ch_constants = ch[2]
    let ch_local_names = ch[3]

    // Code
    let code_len = len(ch_code)
    write_u32_le(code_len)
    for i in 0..code_len {
        write_u8(ch_code[i])
    }

    // Lines
    let lines_len = len(ch_lines)
    write_u32_le(lines_len)
    for i in 0..lines_len {
        write_u32_le(ch_lines[i])
    }

    // Constants
    let const_len = len(ch_constants)
    write_u32_le(const_len)
    for i in 0..const_len {
        serialize_constant(ch_constants[i])
    }

    // Local names
    let name_count = len(ch_local_names)
    write_u32_le(name_count)
    for i in 0..name_count {
        if ch_local_names[i] == nil {
            write_u8(0)
        } else {
            write_u8(1)
            write_string(ch_local_names[i])
        }
    }
}

fn serialize_latc(ch: any) {
    ser_buf = Buffer::new(0)

    // Header: "LATC" + version(1) + reserved(0)
    write_u8(76)    // 'L'
    write_u8(65)    // 'A'
    write_u8(84)    // 'T'
    write_u8(67)    // 'C'
    write_u16_le(1) // format version
    write_u16_le(0) // reserved

    serialize_chunk(ch)
    return ser_buf
}

// ============================================================================
// Section 12: Main entry point
// ============================================================================

fn main() {
    let argv = args()
    if len(argv) < 3 {
        eprint("usage: clat compiler/latc.lat <input.lat> <output.latc>")
        exit(1)
    }

    let input_path = argv[1]
    let output_path = argv[2]

    let source = read_file(input_path)
    if source == nil {
        eprint("error: cannot read '" + input_path + "'")
        exit(1)
    }

    tokens = tokenize(source)
    pos = 0

    compile_program()

    let ch_snap = snapshot_chunk()
    let buf = serialize_latc(ch_snap)

    let ok = write_file_bytes(output_path, buf)
    if !ok {
        eprint("error: cannot write '" + output_path + "'")
        exit(1)
    }
}

// main() is auto-called by the Lattice compiler
